{"head":{"layout":"Post","title":"[Sketch.sh development] Part 2: The engine","date":"2018-12-10T07:00:00.000Z","tags":["sketch-sh","reasonml"],"description":"This post is part of Sketch.sh development series Alright folks, in the first post, I introduced briefly about js_of_ocaml being used for…"},"body":"<blockquote>\n<p>This post is part of <a href=\"/sketch\">Sketch.sh development series</a></p>\n</blockquote>\n<p>Alright folks, <a href=\"/sketch\">in the first post</a>, I introduced briefly about <a href=\"https://ocsigen.org/js_of_ocaml\">js_of_ocaml</a> being used for executing the code in the browser. I call this part of the code base <a href=\"https://github.com/Sketch-sh/engine\"><strong>Sketch engine</strong></a>.</p>\n<h1 id=\"overview-about-ocamls-repl\"><a href=\"#overview-about-ocamls-repl\" class=\"phenomic-HeadingAnchor\">#</a>Overview about OCaml's REPL</h1>\n<p>Official distribution of OCaml comes with a built-in REPL (OCaml folks usually call them Toplevel). you can execute it by typing <code>ocaml</code> in your shell. Though it works, the user interface is very primitive so <a href=\"https://opam.ocaml.org/blog/about-utop/\">utop</a> was born to address the problem. utop has an excellent user interface with context aware code completion and better typing experience. utop is the best REPL I've ever used. </p>\n<blockquote>\n<p>You might wondering what is the relation between <code>rtop</code> and <code>utop</code>? </p>\n<p><code>rtop</code> is an <code>utop</code> version that supports ReasonML syntax.\nWe'll explore about it closely in this post as well.</p>\n</blockquote>\n<pre><code>$ ocaml\n    OCaml version 4.02.0+dev12-2014-07-30\n\n# 1 + 1;;\n- : int = 2\n</code></pre>\n<p>Toplevel provides an interactive interface over the module Toploop. It works by compiling the input code into <strong>bytecode</strong>, executing and getting the result back.</p>\n<h1 id=\"js_of_ocaml\"><a href=\"#js_of_ocaml\" class=\"phenomic-HeadingAnchor\">#</a>js_of_ocaml</h1>\n<p><a href=\"https://ocsigen.org/js_of_ocaml\">js_of_ocaml</a> is a compiler for compiling OCaml <strong>bytecode</strong> to Javascript. Bytecode backend is relatively stable so maintaining <code>js_of_ocaml</code> for newer compiler releases doesn't require much effort.</p>\n<p>For compiling from OCaml bytecode to Javascript with js_of_ocaml, you need to link the package <code>js_of_ocaml</code> and the ppx <code>js_of_ocaml-ppx</code> with ocamlc.</p>\n<pre><code class=\"hljs language-sh\">ocamlfind ocamlc -package js_of_ocaml -package js_of_ocaml-ppx \\\n    -linkpkg -o my_app.byte my_app.ml</code></pre>\n<p>By calling <code>js_of_ocaml</code> on the output bytecode, you get a <code>my_app.js</code> file ready to be embed in your website.</p>\n<pre><code>js_of_ocaml my_app.byte\n</code></pre>\n<h1 id=\"goals-of-this-post\"><a href=\"#goals-of-this-post\" class=\"phenomic-HeadingAnchor\">#</a>Goals of this post</h1>\n<p>As Sketch's codebase changes rapidly, it would be hard to document the code and explain about each module. Instead, I'm going to walk you through building a naive version of Sketch engine. I hope that you can easily understand Sketch's codebase after this. </p>\n<p>There are several code examples in this post, they are located <a href=\"https://github.com/thangngoc89/blog/tree/master/content/sketch/examples\">here</a>. </p>\n<p>I'm using <a href=\"https://esy.sh\">esy</a> as the packages manager so you need to have Node.js available and install esy:</p>\n<pre><code>npm install --global esy\n</code></pre>\n<p>Clone the code:</p>\n<pre><code>git clone https://github.com/thangngoc89/blog\ncd content/sketch/examples\nesy install\nesy build\n</code></pre>\n<p>You can run <code>esy build</code> for building all the examples. In each section, details instruction will be given.</p>\n<h1 id=\"first-version-of-sketch-engine\"><a href=\"#first-version-of-sketch-engine\" class=\"phenomic-HeadingAnchor\">#</a>First version of Sketch engine</h1>\n<p>So getting back to our Sketch engine, <code>Toploop</code> can be compiled to Javascript by default and that's great because it's the heart of our Sketch engine. In the early version of Sketch engine, I used <a href=\"https://github.com/ocsigen/js_of_ocaml/blob/c2a5c19163b757153ec5d408af773789fca022cb/toplevel/lib/jsooTop.mli\"><code>JsooTop</code></a> module which is an abstraction over <code>Toploop</code> module providing by <code>js_of_ocaml-toplevel</code> package.</p>\n<p>Our first version of the engine is simple, you expose a function that take the source code and return the result:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">open</span> Js_of_ocaml;\n\n<span class=\"hljs-keyword\">let</span> execute: Js.t(Js.js_string) => Js.t(Js.js_string) = <span class=\"hljs-built_in\">code</span> => {\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-built_in\">code</span> = Js.to_string(<span class=\"hljs-built_in\">code</span>);\n  <span class=\"hljs-keyword\">let</span> buffer = Buffer.<span class=\"hljs-keyword\">create</span>(<span class=\"hljs-number\">100</span>);\n  <span class=\"hljs-keyword\">let</span> formatter = <span class=\"hljs-keyword\">Format</span>.formatter_of_buffer(buffer);\n  JsooTop.execute(true, formatter, <span class=\"hljs-built_in\">code</span>);\n  <span class=\"hljs-keyword\">let</span> result = Buffer.contents(buffer)\n  Js.<span class=\"hljs-keyword\">string</span>(result);\n};</code></pre>\n<p>Because <code>js_of_ocaml</code> doesn't use Javascript types for representing OCaml types. You need to convert from <code>Js.t(Js.js_string)</code> to <code>string</code>:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">code</span> = Js.to_string(<span class=\"hljs-keyword\">code</span>);</code></pre>\n<p>Next, we need a formatter for storing the evaluated result of the code:</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-attribute\">let buffer</span> = Buffer.create(100);\n<span class=\"hljs-attribute\">let formatter</span> = Format.formatter_of_buffer(buffer);</code></pre>\n<p>Notice how we need to pass a buffer to the formatter? Buffers are extensible strings, you create it with an estimated initial size. Don't worry about the size that much, it will grow to fit the dataset. </p>\n<p>The next step would be executing the code with <code>JsooTop.execute</code> function:</p>\n<pre><code class=\"hljs language-reason\">JsooTop.<span class=\"hljs-built_in\">execute</span>(<span class=\"hljs-literal\">true</span>, formatter, code)<span class=\"hljs-comment\">;</span></code></pre>\n<p>Buffers are mutable so we can get the result back as a string like this:</p>\n<pre><code class=\"hljs language-reason\">let <span class=\"hljs-literal\">result</span> = Buffer.<span class=\"hljs-built_in\">contents</span>(buffer)</code></pre>\n<p>Finally, convert from <code>string</code> to <code>Js.t(Js.js_string)</code> and return it. That's pretty simple right? We get ourselves a working engine in 8 lines of code. Asides from the main <code>execute</code> function, you need to have these lines as well:</p>\n<pre><code class=\"hljs language-reason\">JsooTop.initialize();\nlet () = Js.export_all(\n  [%js {\n    val<span class=\"hljs-built_in\"> execute </span>=<span class=\"hljs-built_in\"> execute\n</span>  }]\n);</code></pre>\n<p>The first line is for initialization of the toplevel, it does several things like populating the toplevel environment, setting up look-up paths,... but we don't need to worry about it right now.</p>\n<p>The next line, we are telling <code>js_of_ocaml</code> that \"Hey, we want the <code>execute</code> function to be callable in Javascript side\" and <code>js_of_ocaml</code> exports it as <code>window.execute</code> if you embed the script or <code>const { execute } = require(\"./engine.bc.js\")</code> if you're requiring it from Node.js.</p>\n<p>You can build our first version of the engine with this command:</p>\n<pre><code>esy dune build one/engine.bc.js --profile release\n</code></pre>\n<p>The generated file is located in <code>_build/default/one/engine.bc.js</code>, let's try that in Node REPL:</p>\n<pre><code class=\"hljs language-bash\">❯ node\n> const { execute } = require(<span class=\"hljs-string\">\"./_build/default/one/engine.bc.js\"</span>)\nundefined\n\n> execute(<span class=\"hljs-string\">\"1 + 1;;\"</span>)\n<span class=\"hljs-string\">'- : int = 2\\n'</span></code></pre>\n<p>Great! So we got ourselves a usable engine that you can embed in your website or calling it from Node.js. But this naive version of the engine has some limitations:</p>\n<ul>\n<li>Errors and logs (stdout, stderr in OCaml) is printed directly to Javascript console, we want to catch them and return them as result of <code>execute</code> function for displaying in the UI.</li>\n</ul>\n<pre><code class=\"hljs language-bash\">> execute(`print_endline <span class=\"hljs-string\">\"Hello world from OCaml\"</span>;;`);\nHello world from OCaml\n<span class=\"hljs-string\">'- : unit = ()\\n'</span>\n\n> execute(`syntax error`);\nFile <span class=\"hljs-string\">\"\"</span>, line 1, characters 12-12:\nError: Syntax error\n<span class=\"hljs-string\">''</span></code></pre>\n<ul>\n<li>It executes all code at once. We want it to return the result for each individual statement (they are called phrases in OCaml's terminology).</li>\n</ul>\n<pre><code class=\"hljs language-bash\">> execute(`<span class=\"hljs-built_in\">let</span> add = (+);; add 1 2;; add 3 4;;`);\n<span class=\"hljs-string\">'val add : int -> int -> int = &#x3C;fun>\\n- : int = 3\\n- : int = 7\\n'</span></code></pre>\n<ul>\n<li>It doesn't support ReasonML syntax yet.</li>\n</ul>\n<h1 id=\"turn-stdout-and-stderr-into-values\"><a href=\"#turn-stdout-and-stderr-into-values\" class=\"phenomic-HeadingAnchor\">#</a>Turn <code>stdout</code> and <code>stderr</code> into values</h1>\n<p><code>stdout</code> and <code>stderr</code> are <code>out_channel</code>. They are flushed to Javscript console by default but we can flush them into a buffer instead.</p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">let</span> stderr_buffer = Buffer.<span class=\"hljs-keyword\">create</span>(<span class=\"hljs-number\">100</span>);\n<span class=\"hljs-keyword\">let</span> stdout_buffer = Buffer.<span class=\"hljs-keyword\">create</span>(<span class=\"hljs-number\">100</span>);\n\nSys_js.set_channel_flusher(stdout, Buffer.add_string(stdout_buffer));\nSys_js.set_channel_flusher(stderr, Buffer.add_string(stderr_buffer));</code></pre>\n<p>Add these lines to the end of <code>execute</code> function: </p>\n<pre><code class=\"hljs language-reason\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-literal\">result</span> = <span class=\"hljs-type\">Buffer</span>.contents(buffer);\n<span class=\"hljs-keyword\">let</span> stderr_result = <span class=\"hljs-type\">Buffer</span>.contents(stderr_buffer);\n<span class=\"hljs-keyword\">let</span> stdout_result = <span class=\"hljs-type\">Buffer</span>.contents(stdout_buffer);\n\n<span class=\"hljs-type\">Buffer</span>.clear(stderr_buffer);\n<span class=\"hljs-type\">Buffer</span>.clear(stdout_buffer);\n\n[%js {\n  val <span class=\"hljs-literal\">result</span> = <span class=\"hljs-type\">Js</span>.<span class=\"hljs-built_in\">string</span>(<span class=\"hljs-literal\">result</span>);\n  val <span class=\"hljs-literal\">stderr</span> = <span class=\"hljs-type\">Js</span>.<span class=\"hljs-built_in\">string</span>(stderr_result);\n  val <span class=\"hljs-literal\">stdout</span> = <span class=\"hljs-type\">Js</span>.<span class=\"hljs-built_in\">string</span>(stdout_result)\n}]</code></pre>\n<p>Here we bind the content of execution result, stderr and stdout into variables and clear the buffer after that. We also return an Javascript object with this shape:</p>\n<pre><code class=\"hljs language-js\">{\n  <span class=\"hljs-attr\">result</span>: string,\n  <span class=\"hljs-attr\">stderr</span>: string,\n  <span class=\"hljs-attr\">stdout</span>: string\n}</code></pre>\n<p>You can build this example with:</p>\n<pre><code>esy dune build two/engine.bc.js --profile release\n</code></pre>\n<p>Test it:</p>\n<pre><code>❯ node\n> const { execute } = require(\"./_build/default/two/engine.bc.js\")\nundefined\n\n> execute(\"1 + 1;;\")\n{ result: '- : int = 2\\n', stderr: '', stdout: '' }\n\n> execute(`print_endline \"Hello world from OCaml\";;`);\n{ result: '- : unit = ()\\n',\n  stderr: '',\n  stdout: 'Hello world from OCaml\\n' }\n\n> execute(`syntax error`);\n{ result: '',\n  stderr: 'File \"\", line 1, characters 12-12:\\nError: Syntax error\\n',\n  stdout: '' }\n</code></pre>\n<p>That looks more promising! We get <code>stderr</code> and <code>stdout</code> as return values. In Sketch UI, This information will be display inline like this</p>\n<p><img src=\"/sketch/images/display-inline.png\" alt=\"Sketch inline errors and values\"></p>\n<h1 id=\"support-reasonml-syntax\"><a href=\"#support-reasonml-syntax\" class=\"phenomic-HeadingAnchor\">#</a>Support ReasonML syntax</h1>\n<p>As I mentioned above, <code>rtop</code> is <code>utop</code> with ReasonML syntax support. Adding ReasonML syntax, we need to install <code>reason</code> package first:</p>\n<pre><code>esy add @esy-ocaml/reason\n</code></pre>\n<p>Add these lines before <code>JsooTop.initialize();</code> in <code>engine.re</code>:</p>\n<pre><code class=\"hljs language-reasonml\"><span class=\"hljs-keyword\">let</span> reasonSyntax = () => {\n  open Reason<span class=\"hljs-number\">_</span>toolchain.From<span class=\"hljs-number\">_</span>current;\n  <span class=\"hljs-keyword\">let</span> wrap = (f, g, fmt, x) => g(fmt, f(x));\n  Toploop.parse<span class=\"hljs-number\">_</span>toplevel<span class=\"hljs-number\">_p</span>hrase :=\n    Reason<span class=\"hljs-number\">_u</span>til.correctly<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">catch</span><span class=\"hljs-number\">_p</span>arse<span class=\"hljs-number\">_</span>errors(x =>\n      Reason<span class=\"hljs-number\">_</span>toolchain.To<span class=\"hljs-number\">_</span>current.copy<span class=\"hljs-number\">_</span>toplevel<span class=\"hljs-number\">_p</span>hrase(\n        Reason<span class=\"hljs-number\">_</span>toolchain.RE.toplevel<span class=\"hljs-number\">_p</span>hrase(x),\n      )\n    );\n  Toploop.parse<span class=\"hljs-number\">_u</span>se<span class=\"hljs-number\">_f</span>ile :=\n    Reason<span class=\"hljs-number\">_u</span>til.correctly<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">catch</span><span class=\"hljs-number\">_p</span>arse<span class=\"hljs-number\">_</span>errors(x =>\n      List.map(\n        Reason<span class=\"hljs-number\">_</span>toolchain.To<span class=\"hljs-number\">_</span>current.copy<span class=\"hljs-number\">_</span>toplevel<span class=\"hljs-number\">_p</span>hrase,\n        Reason<span class=\"hljs-number\">_</span>toolchain.RE.use<span class=\"hljs-number\">_f</span>ile(x),\n      )\n    );\n  Toploop.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">value</span> :=\n    wrap(copy<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">value</span>, Reason<span class=\"hljs-number\">_</span>oprint.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">value</span>);\n  Toploop.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>type := wrap(copy<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>type, Reason<span class=\"hljs-number\">_</span>oprint.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>type);\n  Toploop.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">class</span><span class=\"hljs-number\">_</span>type :=\n    wrap(copy<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">class</span><span class=\"hljs-number\">_</span>type, Reason<span class=\"hljs-number\">_</span>oprint.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">class</span><span class=\"hljs-number\">_</span>type);\n  Toploop.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_m</span>odule<span class=\"hljs-number\">_</span>type :=\n    wrap(copy<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_m</span>odule<span class=\"hljs-number\">_</span>type, Reason<span class=\"hljs-number\">_</span>oprint.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_m</span>odule<span class=\"hljs-number\">_</span>type);\n  Toploop.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>type<span class=\"hljs-number\">_</span>extension :=\n    wrap(copy<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>type<span class=\"hljs-number\">_</span>extension, Reason<span class=\"hljs-number\">_</span>oprint.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>type<span class=\"hljs-number\">_</span>extension);\n  Toploop.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>sig<span class=\"hljs-number\">_</span>item :=\n    wrap(copy<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>sig<span class=\"hljs-number\">_</span>item, Reason<span class=\"hljs-number\">_</span>oprint.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>sig<span class=\"hljs-number\">_</span>item);\n  Toploop.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>signature :=\n    wrap(List.map(copy<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>sig<span class=\"hljs-number\">_</span>item), Reason<span class=\"hljs-number\">_</span>oprint.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_</span>signature);\n  Toploop.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_p</span>hrase :=\n    wrap(copy<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_p</span>hrase, Reason<span class=\"hljs-number\">_</span>oprint.print<span class=\"hljs-number\">_</span><span class=\"hljs-keyword\">out</span><span class=\"hljs-number\">_p</span>hrase);\n};</code></pre>\n<p>What's going here? <a href=\"https://github.com/ocaml/ocaml/blob/62de6552f8ae6b7ac9068823274dc5446b9422c4/toplevel/toploop.mli\"><code>Toploop</code></a> module contains several functions for parsing  and printing values: <code>parse_toplevel_phrase</code>, <code>parse_use_file</code>, <code>print_out_*</code>,... These functions are mutable so we can swap out the original OCaml parser and printer with ReasonML ones. <a href=\"https://github.com/facebook/reason/blob/9914cc69934991b485943847a9196d0d3576d603/src/rtop/reason_utop.ml#L60-L77\">I didn't figure this out myself, the ReasonML team did</a>.</p>\n<p>We also need to copy <code>reason_utils.ml</code> from <a href=\"https://github.com/facebook/reason/blob/9914cc69934991b485943847a9196d0d3576d603/src/rtop/reason_util.ml\">rtop's source code</a> to our project. I chose to vendor this file instead of installing it because <code>rtop</code> depends on <code>utop</code>, and that's a heavy dependencies with lots of primitives that <code>js_of_ocaml</code> can't compile to Javscript.</p>\n<p>You can build this example with:</p>\n<pre><code>esy dune build three/engine.bc.js --profile release\n</code></pre>\n<p>Let's test it:</p>\n<pre><code class=\"hljs language-bash\">> const { execute } = require(<span class=\"hljs-string\">\"./_build/default/three/engine.bc.js\"</span>)\nundefined\n\n> execute(`print_endline(<span class=\"hljs-string\">\"Hello from \"</span> ++ <span class=\"hljs-string\">\"ReasonML\"</span>);`);\n{ result: <span class=\"hljs-string\">'- : unit = ()\\n'</span>,\n  stderr: <span class=\"hljs-string\">''</span>,\n  stdout: <span class=\"hljs-string\">'Hello from ReasonML\\n'</span> }</code></pre>\n<p>You can notice the <code>++</code> operator for string concatenation as well as semicolon as expression seperator indicating ReasonML syntax. If you try the OCaml syntax again, you'll get syntax error:</p>\n<pre><code class=\"hljs language-bash\">> execute(`print_endline (<span class=\"hljs-string\">\"Hello from \"</span> ^ <span class=\"hljs-string\">\"OCaml\"</span>) ;;`);\n{ result: <span class=\"hljs-string\">''</span>,\n  stderr: <span class=\"hljs-string\">'File \"\", line 1, characters 31-41:\\nError: Syntax error\\n'</span>,\n  stdout: <span class=\"hljs-string\">''</span> }</code></pre>\n<p>This is understandable since we replaced OCaml parser and printer with Reason ones. What if we want to support both OCaml and ReasonML syntax at the same time just like [https://sketch.sh]? A naive solution would be keeping 2 seperate version of the engine but <code>engine.bc.js</code> weights about 5.0MB. That's huge for a client-side Javascript file.</p>\n<h1 id=\"wrapping-up\"><a href=\"#wrapping-up\" class=\"phenomic-HeadingAnchor\">#</a>Wrapping up</h1>\n<p>Whoops. That's a lot of stuff going on. In this post, I showed you how to build the simplest version of our engine, turn <code>stdout</code> and <code>stderr</code> into first class values and add ReasonML syntax support.</p>\n<p>I want to thank you Matthias Kern and Bryan Phelps for giving me early feedbacks about this post.</p>\n<h1 id=\"whats-next\"><a href=\"#whats-next\" class=\"phenomic-HeadingAnchor\">#</a>What's next?</h1>\n<p>In the next post, I'll explain about supporting OCaml and ReasonML at the same time as well as getting result for each invidiual phrase</p>\n","__filename":"sketch/part-2-the-engine.md","__url":"/sketch/part-2-the-engine/","__resourceUrl":"/sketch/part-2-the-engine/index.html","__dataUrl":"/sketch/part-2-the-engine/index.html.b794589a9ecb1e69f8301bac95a77189.json"}
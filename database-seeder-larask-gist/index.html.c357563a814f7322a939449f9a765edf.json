{"head":{"layout":"Post","title":"Database Seeder - Tạo dummy data - Larask Gist","date":"2015-03-13T17:00:00.000Z","description":"[Series] Larask Gist - Thiết lập Database Seeder , chuẩn bị dummy data","tags":["laravel"]},"body":"<p>Đây là bài viết thứ 4 trong series <a href=\"/gioi-thieu-series-larask-gist/\">Laravel Gist</a> .</p>\n<p>Các bạn có thể xem code của project tại <a href=\"http://github.com/larask/gist\">Github</a>.</p>\n<hr>\n<h1 id=\"giới-thiệu\"><a href=\"#gi%E1%BB%9Bi-thi%E1%BB%87u\" class=\"phenomic-HeadingAnchor\">#</a>Giới thiệu</h1>\n<p>Chúng ta đã tạo migration, model và cả sử dụng Uuid trong model\nnhưng chúng ta vẫn chưa có bất cứ dữ liệu nào để sử dụng.</p>\n<p>Làm sao để biết ứng dụng của chúng ta chạy đúng theo mong muốn?</p>\n<p>Làm sao để kiểm tra mọi trường hợp, mọi kiểu data mà user có thể nhập vào?\nChúng ta có thể tạo data bằng tay rồi sau đó import vào database.</p>\n<p>Đó là một công việc hết sức nhàm chán và tốn thời gian.\nĐể mình chỉ cho các bạn các nhanh hơn.</p>\n<h1 id=\"trước-khi-bắt-đầu\"><a href=\"#tr%C6%B0%E1%BB%9Bc-khi-b%E1%BA%AFt-%C4%91%E1%BA%A7u\" class=\"phenomic-HeadingAnchor\">#</a>Trước khi bắt đầu</h1>\n<p>Hãy chạy lệnh <code>php artisan migrate:refresh</code> để áp dụng schema mà chúng ta đã thay đổi trong bài trước. Lệnh <code>migrate:refresh</code> thực tế là chạy 2 lệnh sau lần lượt: <code>migrate:rollback</code> và <code>migrate</code>. Không có gì mới ở đây cả.</p>\n<h1 id=\"database-seeder\"><a href=\"#database-seeder\" class=\"phenomic-HeadingAnchor\">#</a>Database Seeder</h1>\n<p>Các bạn có thể hiểu database seeder là class chứa code để tạo ra dummy data. Khi chạy lệnh <code>php artisan db:seed</code>, Laravel sẽ gọi method <code>run()</code> trong file <code>database/seeds/DatabaseSeeder.php</code> .  Tuy nhiên, để tiện quản lí, chúng ta sẽ tạo riêng cho mỗi table 1 file và gọi các file này từ <code>DatabaseSeeder</code>.</p>\n<h1 id=\"tạo-seeder\"><a href=\"#t%E1%BA%A1o-seeder\" class=\"phenomic-HeadingAnchor\">#</a>Tạo seeder</h1>\n<p>Ở <a href=\"/model-va-migration-trong-laravel-5-gist/\">bài trước</a> chúng ta có lệnh <code>php artisan make:model</code> để tạo nhanh model và migration cho model. Laravel đi kèm với 1 danh sách các lệnh để tạo nhanh các file. Các bạn có thể xem toàn bộ lệnh của <code>artisan</code> bằng cách chạy lệnh <code>php artisan</code>. Nhưng rất tiếc, không có lệnh tạo database seeder. Chúng ta sẽ cài đặt package <a href=\"https://github.com/laracasts/Laravel-5-Generators-Extended\">Laravel 5 Generators Extended</a> để có được lệnh này. Về phần cài đặt, các bạn có thể xem readme để cài đặt.</p>\n<p>Sau khi cài đặt xong. Chúng ta đã có thể sử dụng <code>php artisan make:seed</code>. Ở đây, mình sẽ chạy 2 lệnh sau để tạo seeder cho User và Gist.</p>\n<pre><code class=\"hljs language-shell\">php artisan make:seed gist\nphp artisan make:seed user</code></pre>\n<p>Sau khi hoàn thành chúng ta sẽ có 2 file <code>UserTableSeeder.php</code> và <code>GistTableSeeder.php</code> trong <code>app/database/seeds</code>. Mở file <code>DatabaseSeeder.php</code> trong cùng thư mục và thêm vào trong method <code>run()</code> :</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-keyword\">$this</span>->call(UserTableSeeder::class);\n<span class=\"hljs-keyword\">$this</span>->call(GistTableSeeder::class);</code></pre>\n<p>File <code>DatabaseSeeder.php</code> của chúng ta lúc này :</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-meta\">&#x3C;?php</span>\n\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Illuminate</span>\\<span class=\"hljs-title\">Database</span>\\<span class=\"hljs-title\">Seeder</span>;\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Illuminate</span>\\<span class=\"hljs-title\">Database</span>\\<span class=\"hljs-title\">Eloquent</span>\\<span class=\"hljs-title\">Model</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DatabaseSeeder</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Seeder</span> </span>{\n  <span class=\"hljs-comment\">/**\n   * Run the database seeds.\n   *\n   * <span class=\"hljs-doctag\">@return</span> void\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span>\n  </span>{\n    Model::unguard();\n\n    <span class=\"hljs-keyword\">$this</span>->call(UserTableSeeder::class);\n    <span class=\"hljs-keyword\">$this</span>->call(GistTableSeeder::class);\n  }\n}</code></pre>\n<p>Từ này, mỗi khi chúng ta chạy lệnh <code>php artisan db:seed</code>, method <code>run()</code> trong <code>UserTableSeeder</code> và <code>GistTableSeeder</code> sẽ được gọi theo thứ tự.</p>\n<h1 id=\"dummy-data\"><a href=\"#dummy-data\" class=\"phenomic-HeadingAnchor\">#</a>Dummy Data</h1>\n<p>Bây giờ là phần quan trọng nhất, dummy data. Và để thuận tiện, chung1ta tiếp tục sử dụng 1 package khác của Laracasts : <a href=\"https://github.com/laracasts/TestDummy\">Test Dummy</a>.</p>\n<p>Sau khi cài đặt, các bạn mở class <code>UserTableSeeder</code> và thêm vào method <code>run()</code> đoạn :</p>\n<pre><code class=\"hljs language-php\">TestDummy::times(<span class=\"hljs-number\">100</span>)->create(<span class=\"hljs-string\">'Gist\\User'</span>);`</code></pre>\n<p>Nhớ import class TestDummy vào:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Laracasts</span>\\<span class=\"hljs-title\">TestDummy</span>\\<span class=\"hljs-title\">Factory</span> <span class=\"hljs-title\">as</span> <span class=\"hljs-title\">TestDummy</span>;</code></pre>\n<p>Mục đích của đoạn code trên là sẽ tạo 100 record cho <code>Gist\\User</code> của chúng ta. Tuy nhiên, <code>TestDummy</code> không thần kì tới mức có thể xác định được loại data nào cần sử dụng mà chúng ta cần phải định nghĩa chúng.</p>\n<h2 id=\"testdummy-factories\"><a href=\"#testdummy-factories\" class=\"phenomic-HeadingAnchor\">#</a>TestDummy Factories</h2>\n<p>Tạo file <code>tests/factories/factories.php</code>. Trong class <code>UserTableSeeder</code> chúng ta cần <code>Gist\\User</code> factory. Vì vậy trong file <code>factories.php</code> chúng ta sẽ định nghĩa factory này như sau:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-meta\">&#x3C;?php</span>\n\n$factory(<span class=\"hljs-string\">'Gist\\User'</span>, [\n  <span class=\"hljs-string\">'name'</span> => $faker->sentence,\n  <span class=\"hljs-string\">'username'</span> => $faker->unique()->userName,\n  <span class=\"hljs-string\">'email'</span> => $faker->unique()->email,\n  <span class=\"hljs-string\">'password'</span> => $faker->words, <span class=\"hljs-comment\">// $faker->password doesn't work</span>\n]);</code></pre>\n<p><em>Lưu ý: Tên factory chính là namespace của model</em></p>\n<p>Các bạn đang thắc mắc <code>$faker</code> là gì? Đó là 1 instance của package <a href=\"https://github.com/fzaninotto/Faker\">fzaninotto/Faker</a> dùng để tạo các thông tin ngẫu nhiên như là <code>lorem ipsum</code> . Các bạn có thể xem đầy đủ các loại thông tin mà Faker hỗ trợ trong file readme.</p>\n<p>OK. Thử chạy <code>php artisan db:seed</code>, nếu ko có lỗi gì xảy ra chúng ta sẽ thấy 100 row trong table users. Thật là dễ dàng phải không nào?</p>\n<p>Chúng ta tiếp tục thực hiện tương tự đối với <code>Gist</code> Model.</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-meta\">&#x3C;?php</span>\n<span class=\"hljs-comment\">// app/database/seeders/GistTableSeeder.php</span>\n\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Illuminate</span>\\<span class=\"hljs-title\">Database</span>\\<span class=\"hljs-title\">Seeder</span>;\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Laracasts</span>\\<span class=\"hljs-title\">TestDummy</span>\\<span class=\"hljs-title\">Factory</span> <span class=\"hljs-title\">as</span> <span class=\"hljs-title\">TestDummy</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GistTableSeeder</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Seeder</span> </span>{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n      TestDummy::times(<span class=\"hljs-number\">100</span>)->create(<span class=\"hljs-string\">'Gist\\Gist'</span>);\n  }\n}</code></pre>\n<p>Trong file <code>tests/factories/factories.php</code> thêm vào :</p>\n<pre><code class=\"hljs language-php\">$factory(<span class=\"hljs-string\">'Gist\\Gist'</span>, [\n  <span class=\"hljs-string\">'title'</span> => $faker->sentence,\n  <span class=\"hljs-string\">'content'</span> => $faker->paragraph,\n  <span class=\"hljs-string\">'public'</span> => $faker->boolean,\n  <span class=\"hljs-string\">'user_id'</span> => <span class=\"hljs-string\">'factory:Gist\\User'</span>,\n]);</code></pre>\n<p>Mục cần chúng ta cần chú ý đó chính là <code>user_id</code> . <code>factory:Gist\\User</code> sẽ chỉ <code>TestDummy</code> lấy 1 id của <code>Gist\\User</code> factory chèn vào đó. Như vậy chúng ta đã có <code>Gist\\Gist</code> factory.</p>\n<p>Chạy thử: <code>php artisan db:seed</code> và 100 row sẽ xuất hiện trong <code>gists</code> table. Nhưng có 2 vấn đề xảy ra:</p>\n<ol>\n<li>Trong <code>users</code> table, 100 row mới sẽ xuất hiện và chúng ta có tất cả 200 rows trong <code>users</code> table.</li>\n<li>Tất cả  <code>user_id</code> đều giống nhau trong <code>gists</code> table.</li>\n</ol>\n<p>Chúng ta sẽ lần lượt giải quyết chúng trong các phần tiếp theo.</p>\n<h2 id=\"truncate-table\"><a href=\"#truncate-table\" class=\"phenomic-HeadingAnchor\">#</a>Truncate Table</h2>\n<p>Để tránh việc có thêm 100 dòng mỗi khi chạy <code>db:seed</code> chúng ta sẽ chạy lệnh <code>TRUNCATE TABLE table-name</code> trước khi seed.</p>\n<p>Mở class <code>DatabaseSeeder</code> và thêm vào đầu method <code>run()</code></p>\n<pre><code class=\"hljs language-php\">DB::statement(<span class=\"hljs-string\">'TRUNCATE TABLE users'</span>);\nDB::statement(<span class=\"hljs-string\">'TRUNCATE TABLE gists'</span>);</code></pre>\n<p>Thử chạy và lỗi <code>constraint</code> sẽ xuất hiện do foreign constrain giữa <code>users</code> table và <code>gists</code> table.</p>\n<p>Chúng ta có để đổi vị trí của 2 dòng code cho nhau để khắc phục lỗi constraint. Tuy nhiên đó không phải giải pháp lâu dài, vì khi ứng dụng phát triển, các table có quan hệ chặt chẽ với nhau và chúng ta không thể nào xác định được table nào <code>truncate</code> trước sẽ không bị lỗi. Giải pháp của chúng ta là sẽ tắt kiểm tra <code>foreign key</code> trước khi <code>truncate</code> và bật lại nó sau khi đã hoàn thành.</p>\n<p>Đây là method <code>run()</code> hoàn chỉnh sau khi đã tích hợp lệnh :</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span>\n</span>{\n  DB::statement(<span class=\"hljs-string\">'SET FOREIGN_KEY_CHECKS=0'</span>);\n\n  DB::statement(<span class=\"hljs-string\">'TRUNCATE TABLE users'</span>);\n  DB::statement(<span class=\"hljs-string\">'TRUNCATE TABLE gists'</span>);\n\n  DB::statement(<span class=\"hljs-string\">'SET FOREIGN_KEY_CHECKS=0'</span>);\n\n  Model::unguard();\n\n  <span class=\"hljs-keyword\">$this</span>->call(UserTableSeeder::class);\n  <span class=\"hljs-keyword\">$this</span>->call(GistTableSeeder::class);\n}</code></pre>\n<h2 id=\"tạo-user_id-khác-nhau\"><a href=\"#t%E1%BA%A1o-user_id-kh%C3%A1c-nhau\" class=\"phenomic-HeadingAnchor\">#</a>Tạo user_id khác nhau</h2>\n<p>Như chúng ta đã biết ở trên thì khi chạy <code>db:seed</code> tất cả <code>user_id</code> trong <code>gists</code> table sẽ giống nhau. Đây không phải là lỗi mà là cơ chế hoạt động của <code>TestDummy</code>. Để khắc phục, thay vì ra lệnh cho <code>TestDummy</code> tạo 100 row thì chúng ta sẽ chạy <code>TestDummy</code> 100 lần, mỗi lần tạo 1 row.</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-meta\">&#x3C;?php</span>\n\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Illuminate</span>\\<span class=\"hljs-title\">Database</span>\\<span class=\"hljs-title\">Seeder</span>;\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Laracasts</span>\\<span class=\"hljs-title\">TestDummy</span>\\<span class=\"hljs-title\">Factory</span> <span class=\"hljs-title\">as</span> <span class=\"hljs-title\">TestDummy</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GistTableSeeder</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Seeder</span> </span>{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">foreach</span>(range(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">as</span> $index) {\n        TestDummy::times(<span class=\"hljs-number\">1</span>)->create(<span class=\"hljs-string\">'Gist\\Gist'</span>);\n    }\n  }\n}</code></pre>\n<p>Tuy nhiên, đoạn code trên vẫn chưa tối ưu lắm vì 1 user chỉ có 1 Gist. (có thể <code>TestDummy</code> sẽ chọn lại 1 user_id bị trùng nhưng xác suất là rất thấp). Để tạo ra 1 database ngẫu nhiên hơn nữa. Chúng ta sẽ dùng function <code>rand()</code>.</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-meta\">&#x3C;?php</span>\n\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Illuminate</span>\\<span class=\"hljs-title\">Database</span>\\<span class=\"hljs-title\">Seeder</span>;\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Laracasts</span>\\<span class=\"hljs-title\">TestDummy</span>\\<span class=\"hljs-title\">Factory</span> <span class=\"hljs-title\">as</span> <span class=\"hljs-title\">TestDummy</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GistTableSeeder</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Seeder</span> </span>{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">foreach</span>(range(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">as</span> $index) {\n      TestDummy::times(rand(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>))->create(<span class=\"hljs-string\">'Gist\\Gist'</span>);\n    }\n  }\n}</code></pre>\n<p>Như vậy, chúng ta sẽ chạy <code>TestDummy</code> 100 lần, mỗi lần <code>TestDummy</code> sẽ thêm vào ngẫu nhiên 1-5 records. Các bạn có thể muốn giảm 100 xuống 1 con số thấp hơn để khỏi mất công chờ.</p>\n<h1 id=\"kết-luận\"><a href=\"#k%E1%BA%BFt-lu%E1%BA%ADn\" class=\"phenomic-HeadingAnchor\">#</a>Kết luận</h1>\n<p>Qua bài này, các bạn đã biết được cách dùng <code>TestDummy</code> kết hợp với <code>Faker</code> để tạo dummy data phục vụ cho việc develop và testing.</p>\n<p>Mình và anh <a href=\"http://blog.luuhoangnam.com/\">Nam</a> đã push vài commit để hiển thị các database này ra ngoài dưới dạng json. Các bạn có thể clone về, cài đặt như bình thường (xem file readme) và truy cập vào route <code>/trending</code> để xem thử.</p>\n","__filename":"database-seeder-larask-gist.md","__url":"/database-seeder-larask-gist/","__resourceUrl":"/database-seeder-larask-gist/index.html","__dataUrl":"/database-seeder-larask-gist/index.html.c357563a814f7322a939449f9a765edf.json"}
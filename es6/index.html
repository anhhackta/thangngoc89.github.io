<!doctype html><html lang="en" manifest="/manifest.appcache"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/w-2-client.d91ba49a782b197ca599.css" /><meta data-react-helmet="true" property="og:site_name" content="Khoa Nguyen Blog"/><meta data-react-helmet="true" name="twitter:site" content="@khoanguyenme"/><meta data-react-helmet="true" property="og:title" content="Tổng quan ES6 qua 350 điểm - Khoa Nguyen Blog"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:url" content="https://khoanguyen.me/es6/"/><meta data-react-helmet="true" property="og:description" content="Giới thiệu

ES6, còn được biết với tên Harmony, es-next, ES2015 là bản mô tả mới nhất của Javascript

Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)

Các bản mô tả tiếp theo…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="Tổng quan ES6 qua 350 điểm - Khoa Nguyen Blog"/><meta data-react-helmet="true" name="twitter:creator" content="@khoanguyenme"/><meta data-react-helmet="true" name="twitter:description" content="Giới thiệu

ES6, còn được biết với tên Harmony, es-next, ES2015 là bản mô tả mới nhất của Javascript

Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)

Các bản mô tả tiếp theo…"/><meta data-react-helmet="true" name="description" content="Giới thiệu

ES6, còn được biết với tên Harmony, es-next, ES2015 là bản mô tả mới nhất của Javascript

Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)

Các bản mô tả tiếp theo…"/><title data-react-helmet="true">Tổng quan ES6 qua 350 điểm</title></head><body><div id="statinamic"><div id="statinamic-container" data-reactid=".141kppb7qbk" data-react-checksum="315264156"><div data-reactid=".141kppb7qbk.0"><noscript data-reactid=".141kppb7qbk.0.0"></noscript><div class="react-progress-bar react-progress-bar-hide" data-reactid=".141kppb7qbk.0.1"><div class="react-progress-bar-percent" style="width:100%;" data-reactid=".141kppb7qbk.0.1.0"></div><div class="react-progress-bar-spinner" data-reactid=".141kppb7qbk.0.1.1"><div class="react-progress-bar-spinner-icon" data-reactid=".141kppb7qbk.0.1.1.0"></div></div></div><nav class="Header--nav--39_s9" data-reactid=".141kppb7qbk.0.2"><div class="container" data-reactid=".141kppb7qbk.0.2.0"><a class="Header--brand--1Mwg_" href="/" data-reactid=".141kppb7qbk.0.2.0.0">Khoa Nguyen</a><a href="https://github.com/thangngoc89" target="_blank" class="Header--navLink--1rVGb" data-reactid=".141kppb7qbk.0.2.0.1"><i class="icon-github" data-reactid=".141kppb7qbk.0.2.0.1.0"></i></a><a class="Header--navLink--1rVGb" href="/about/" data-reactid=".141kppb7qbk.0.2.0.2"><i class="icon-user" data-reactid=".141kppb7qbk.0.2.0.2.0"></i><span data-reactid=".141kppb7qbk.0.2.0.2.1">Giới thiệu</span></a><a class="Header--navLink--1rVGb" href="/archive/" data-reactid=".141kppb7qbk.0.2.0.3"><i class="icon-bookmark" data-reactid=".141kppb7qbk.0.2.0.3.0"></i><span data-reactid=".141kppb7qbk.0.2.0.3.1">Bài viết</span></a></div></nav><div data-reactid=".141kppb7qbk.0.3"><div class="container" data-reactid=".141kppb7qbk.0.3.3"><noscript data-reactid=".141kppb7qbk.0.3.3.0"></noscript><noscript data-reactid=".141kppb7qbk.0.3.3.1"></noscript><div class="row" data-reactid=".141kppb7qbk.0.3.3.2"><div class="Post--contentColumn--3GUYR center-block" data-reactid=".141kppb7qbk.0.3.3.2.0"><h1 class="Post--title--15MlK" data-reactid=".141kppb7qbk.0.3.3.2.0.0">Tổng quan ES6 qua 350 điểm</h1><span class="Post--date--PSjxO" data-reactid=".141kppb7qbk.0.3.3.2.0.1">21 tháng 2 2016</span><span class="Post--readTime--Bx7DX" data-reactid=".141kppb7qbk.0.3.3.2.0.2"><span data-reactid=".141kppb7qbk.0.3.3.2.0.2.0">~ </span><span data-reactid=".141kppb7qbk.0.3.3.2.0.2.1">9 phút</span></span><article class="Post--article--2lUZz" data-reactid=".141kppb7qbk.0.3.3.2.0.3"><h1 id="Gioi-thieu"><a class="markdownIt-Anchor" href="#Gioi-thieu">#</a> Giới thiệu</h1>
<ul>
<li>
<p>ES6, còn được biết với tên Harmony, <code>es-next</code>, ES2015 là bản mô tả mới nhất của Javascript</p>
</li>
<li>
<p>Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)</p>
</li>
<li>
<p>Các bản mô tả tiếp theo của Javascript sẽ được đặt tên theo dạng ES[YYYY], ví dụ ES2016 cho ES7</p>
<ul>
<li>Sẽ cập nhật mỗi năm, tính năng nào không hoàn thành sẽ bị hoãn lại tới năm tiếp theo</li>
<li>Vì ES6 được bắt đầu trước khi cách gọi mới này ra đời nên chúng ta vẫn thường gọi là ES6</li>
<li>Bắt đầu từ ES2016 (ES7), chúng ta nên bắt đầu dùng dạng ES[YYYY] để gọi tên phiên bản Javascript.</li>
<li>Lý do quan trọng nhất khi đặt tên như vậy là để gây áp lực, và buộc các trình duyệt phải thêm tính năng mới vào nhanh hơn.</li>
</ul>
</li>
</ul>
<h1 id="Cong-cu"><a class="markdownIt-Anchor" href="#Cong-cu">#</a> Công cụ</h1>
<ul>
<li>
<p>Để làm việc với ES6 ngay từ bây giờ, bạn cần transpiler <strong>Javascript-to-Javascript</strong></p>
</li>
<li>
<p>Transpiler có chức năng</p>
<ul>
<li>Biên dịch code của bạn từ phiên bản mới nhất (của Javascript) về phiên bản cũ hơn</li>
<li>Khi mà trình duyệt đã tương thích với phiên bản mới, chúng ta sẽ biên dịch từ ES2016 và ES2017 về ES6, … và tiếp tục như vậy.</li>
<li>Hỗ trợ source map</li>
<li>Bạn có thể tự tin viết code ES6 và dùng trong thực tế ngay từ bây giờ (tuy nhiên, trình duyệt sẽ nhận được code ES5)</li>
</ul>
</li>
<li>
<p>Babel (một transpiler) có một tính năng mà không có đối thủ nào cạnh tranh được: xuất ra code mà bạn <strong>có thể đọc được</strong></p>
<ul>
<li>Dùng <code>babel</code> để biên dịch ES6 xuống ES5</li>
<li>Dùng <code>babelify</code> kết hợp với <code>babel</code> cùng với Gulp, Grunt, hoặc npm run trong khi build.</li>
<li>Dùng Node.js v4.x.x sẽ có native support cho ES6 (:+1: cho V8)</li>
<li>Dùng <code>babel-node</code> với bất kì phiên bản node nào, sẽ biên dịch module xuống ES5</li>
<li>Babel có một kho plugins và hệ sinh thái phong phú.</li>
</ul>
</li>
</ul>
<h1 id="Destructuring"><a class="markdownIt-Anchor" href="#Destructuring">#</a> Destructuring</h1>
<ul>
<li>
<p><code>var {foo} = pony</code> tương đượng với <code>var foo = pony.foo</code></p>
</li>
<li>
<p><code>var {foo: baz} = pony</code> tương đương với <code>var baz = pony.foo</code></p>
</li>
<li>
<p>Bạn có thể cung cấp giá trị mặc định , <code>var {foo='bar'} = baz</code> cho ra <code>foo: 'bar'</code> nếu <code>baz.foo === undefined</code></p>
</li>
<li>
<p>Bạn có thể lấy bao nhiêu giá trị tùy thích <code>var {foo, bar: baz} = {foo: 0, bar: 1}</code> cho ra <code>foo: 0</code> và <code>baz: 1</code></p>
</li>
<li>
<p>Bạn có thể lấy giá trị lồng vào nhau. <code>var {foo: {bar}} = { foo: { bar: 'baz' } }</code> cho ra  <code>bar: 'baz'</code></p>
</li>
<li>
<p>Bạn cũng có thể đặt tên cho nó. <code>var {foo: {bar: deep}} = { foo: { bar: 'baz' } }</code> cho ra <code>deep: 'baz'</code></p>
</li>
<li>
<p>Thuộc tính không tình thấy sẽ cho ra <code>undefined</code> như bình thường. Ví dụ <code>var {foo} = {}</code></p>
</li>
<li>
<p>Giá trị lồng vào nhau không tồn tại sẽ cho ra lỗi, ví dụ: <code>var {foo: {bar}} = {}</code></p>
</li>
<li>
<p>Mảng cũng tương tự, <code>[a, b] = [0, 1]</code> cho ra <code>a: 0</code> và <code>b: 1</code></p>
</li>
<li>
<p>Bạn có thể bỏ qua các giá trị trong mảng, <code>[a, , b] = [0, 1, 2]</code>, cho ra <code>a: 0</code> và <code>b: 2</code></p>
</li>
<li>
<p>Bạn có thể thay đổi vị trí mà không cần biết trung gian <code>[a, b] = [b, a]</code></p>
</li>
<li>
<p>Bạn cũng có thể destruct các tham số của hàm</p>
<ul>
<li>Gán giá trị mặc định cho hàm <code>function foo (bar=2) {}</code></li>
<li>Giá trị mặc định cũng có thể là object <code>function foo (bar={ a: 1, b: 2 }) {}</code></li>
<li>Chúng ta có thể destruct biến <code>bar</code> ở trên hoàn toàn thế này <code>function foo ({ a=1, b=2 }) {}</code></li>
<li>Hoặc có thể đặt giá trị mặt định là một object rỗng nếu như không có bất kì tham số nào <code>function foo ({ a=1, b=2 } = {}) {}</code></li>
</ul>
</li>
</ul>
<h1 id="Spread-Operator-and-Rest-Parameters"><a class="markdownIt-Anchor" href="#Spread-Operator-and-Rest-Parameters">#</a> Spread Operator and Rest Parameters</h1>
<ul>
<li>
<p>Rest Parameters (tạm dịch là các tham số còn lại) sẽ <code>arguments</code> tốt hơn</p>
<ul>
<li>Bạn có thể định nghĩa nó trong hàm thế này <code>function foo (...everything) {}</code></li>
<li><code>everything</code> là một mảng gồm tất cả tham số được gửi đến hàm <code>foo</code></li>
<li>Bạn có thể đặt tên cho vài tham số trước <code>...everything</code> thế này <code>function foo (bar, ...rest) {}</code></li>
<li>Các tham số đã được đặt tên sẽ được loại ra khỏi <code>...rest</code></li>
<li><code>...rest</code> phải là tham số cuối cùng trong danh sách</li>
</ul>
</li>
<li>
<p>Spread operator giống như là ma thuật, nó cũng có cú pháp <code>...</code></p>
<ul>
<li>Không cần dùng <code>.apply</code> khi gọi method, <code>fn(...[1, 2, 3])</code> tương đương với <code>fn(1, 2, 3)</code></li>
<li>Dễ gộp mạng hơn <code>[1, 2, ...[3, 4, 5], 6, 7]</code></li>
<li>Chuyển đổi các biến dạng mảng hoặc <code>iterable</code> thành mảng, ví dụ: <code>[...document.querySelectorAll('img')]</code></li>
<li>Có thể dùng khi destruct, <code>[a, , ...rest] = [1, 2, 3, 4, 5]</code> cho ra <code>a: 1</code> và <code>rest: [3, 4, 5]</code></li>
<li>Cần thiết khi dùng <code>new Date</code> thế này <code>new Date(...[2015, 31, 8])</code></li>
</ul>
</li>
</ul>
<h1 id="Arrow-function"><a class="markdownIt-Anchor" href="#Arrow-function">#</a> Arrow function</h1>
<ul>
<li>
<p>Tạo hàm nhanh chóng thế này <code>param =&gt; returnValue</code></p>
</li>
<li>
<p>Hữu ích khi lập trình hàm (funtional programing) <code>[1, 2].map(x =&gt; x * 2)</code></p>
</li>
<li>
<p>Có nhiều cách để dùng, có thể làm bạn rối lúc đầu</p>
<ul>
<li><code>p1 =&gt; expr</code> khi chỉ có một tham số</li>
<li><code>p1 =&gt; expr</code> có nghĩa là hàm sẽ trả về kết quả <code>expr</code></li>
<li>Để trả về một object, đặt nó trong một cặp ngoặc <code>() =&gt; ({ foo: 'bar' })</code> nếu không sẽ bị lỗi cú pháp</li>
<li>Cặp ngoặc có thể dùng khi bạn có không, một, hai hoặc nhiều tham số hơn <code>() =&gt; expr or (p1, p2) =&gt; expr</code></li>
<li>Cặp ngoặc bên phải có nghĩa là khối code có thể có nhiều dòng <code>() =&gt; {}</code></li>
<li>Khi bạn dùng khối code, sẽ không có <code>return</code> tự động, bạn phải thêm vào như mọi khi <code>() =&gt; { return 'foo' }</code></li>
</ul>
</li>
<li>
<p>You can’t name arrow functions statically, but runtimes are now much better at inferring names for most methods.</p>
</li>
<li>
<p>Scope trong arrow function chính là scope của chính arrow function</p>
<ul>
<li><code>this</code> trong arrow function sẽ giống với <code>this</code> ở parent scope.</li>
<li><code>this</code> không thể thay đổi bằng <code>.call</code>, <code>.apply</code>, hoặc là các phương thức tương tự.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Xem thêm: [<a href="http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function">http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function</a>]</p>
</blockquote>
<h1 id="Template-Literals"><a class="markdownIt-Anchor" href="#Template-Literals">#</a> Template Literals</h1>
<ul>
<li>
<p>Bạn có thể định nghĩa chuỗi với dấu <code>`</code> (backtick), thay vì kiểu cũ là <code>&quot;</code> và <code>'</code></p>
</li>
<li>
<p>Chuỗi mà bao trong dấu backtick gọi là template literals</p>
</li>
<li>
<p>Template literals có thể gồm nhiều dòng</p>
</li>
<li>
<p>Template literals cho phép bạn đặt biến vào thế này <code>khoanguyen.me is ${rating}</code> (với <code>rating</code> là một biến)</p>
</li>
<li>
<p>Bạn có thể đặt vào bất cứ thứ gì hợp lệ với Javascript trong cặp ngoặc như <code>${2 * 3}</code> hoặc <code>${foo()}</code></p>
</li>
<li>
<p>Bạn có thể thay đổi kết quả kết template literals</p>
<ul>
<li>Thêm vào trước <code>fn</code> thế này ``fn`foo, ${bar} and ${baz}```</li>
<li><code>fn</code> sẽ được gọi với tham số  <code>template, ...expressions</code></li>
<li><code>template</code> là <code>['foo, ', ' and ', '']</code> và <code>expressions</code> là <code>[bar, baz]</code></li>
<li>Kết quả trả về của <code>fn</code> sẽ trở thành giá trị của template literal.</li>
</ul>
</li>
<li>
<p>Tổng kết lại thì định nghĩa chuỗi với template literals tốt hơn so với việc dùng cặp nháy đơn hay nháy kép</p>
</li>
</ul>
<h1 id="Object-Literals"><a class="markdownIt-Anchor" href="#Object-Literals">#</a> Object Literals</h1>
<ul>
<li>Thay vì phải viết <code>{ foo: foo }</code>, bây giờ bạn chỉ cần viết  <code>{ foo }</code> – đây được gọi <em>property value shorthand</em> (tạm dịch: định nhanh giá trị của thuộc tính)</li>
<li>Tính toán tên thuộc tính (<em>Computed property names</em>), <code>{ [prefix + 'Foo']: 'bar' }</code>, khi <code>prefix: 'moz'</code>, sẽ cho ra kết quả <code>{ mozFoo: 'bar' }</code></li>
<li>Bạn không thể kết hợp computed property names và property value shorthands, <code>{ [foo] }</code> là không hợp lệ</li>
<li>Bạn có thể định method cho object literal bằng cú pháp nhanh này: <code>{ foo () {} }</code></li>
</ul>
<h1 id="Class"><a class="markdownIt-Anchor" href="#Class">#</a> Class</h1>
<ul>
<li>Không phải là class như OOP, chỉ là một cú pháp gọn hơn dựa trên prototype</li>
<li>Cú pháp giống như định object <code>class Foo {}</code></li>
<li>Instance methods – <code>new Foo().bar</code> – được định nghĩa nhờ cú pháp <em>object literal</em> như trên <code>class Foo { bar () {} }</code></li>
<li>Static methods – <code>Foo.isPonyFoo()</code> – cần thêm <code>static</code> vào trước, <code>class Foo { static isPonyFoo () {} }</code></li>
<li>Constructor  <code>class Foo { constructor () { /* initialize instance */ } }</code></li>
<li>Thừa kế nhờ cấu trúc thế này <code>class PonyFoo extends Foo {}</code></li>
</ul>
<h1 id="Let-va-Const"><a class="markdownIt-Anchor" href="#Let-va-Const">#</a> Let và Const</h1>
<ul>
<li>
<p><code>let</code> và <code>const</code> là hai cách khác ngoài <code>var</code> để khởi tạo biến.</p>
</li>
<li>
<p><code>let</code> là <code>block-scoped</code> thay vì <code>lexically scoped</code> như hàm.</p>
</li>
<li>
<p><code>let</code> gắn với <code>block</code> hiện tại, trong khi <code>var</code> gắn với <code>block</code> của hàm</p>
</li>
<li>
<p>“Temporal Dead Zone” (gọi tắt TDZ)</p>
<ul>
<li>Bắt đầu ở <code>block</code> mà <code>let foo</code> được khởi tạo</li>
<li>Kết thúc khi thực hiện câu lệnh khởi tạo <code>let foo</code></li>
<li>Cố gắng truy cập hoặc gán biến trong vùng TDZ (tức là trước câu lên <code>let foo</code>) sẽ gây ra lỗi</li>
<li>Giúp tránh các lỗi đau đầu khi biến bị thay đổi trước khi nó được khởi tạo (có thể hiểu như là <code>&quot;use strict&quot;</code>)</li>
</ul>
</li>
<li>
<p><code>const</code> cũng là <code>block-scoped</code> gắn và ràng buộc bởi TDZ</p>
</li>
<li>
<p>Khi dùng <code>const</code>, biến cần phải gắn giá trị ngay khi khởi tạo <code>const foo = 'bar'</code></p>
</li>
<li>
<p>Gán giá trị cho <code>const</code> sau khi khởi tạo sẽ gây lỗi một ách im lặng hay <code>throw</code> trong <code>&quot;use strict&quot;</code>.</p>
</li>
<li>
<p>Giá trị của biến <code>const</code> không phải là hằng định (immutable)</p>
<ul>
<li><code>const foo = { bar: 'baz' }; foo.bar = 'boo'</code> sẽ không <code>throw</code> lỗi</li>
</ul>
</li>
<li>
<p>Khởi tạo biến cùng tên sẽ <code>throw</code> lỗi</p>
</li>
<li>
<p>Định tạo ra để khắc phục vấn đề ghi đè biến.</p>
</li>
</ul>
<h1 id="Symbol"><a class="markdownIt-Anchor" href="#Symbol">#</a> Symbol</h1>
<ul>
<li>Một kiểu dữ liệu mới của ES6</li>
<li>Bạn có thể khởi tạo symbol thế này <code>var symbol = Symbol()</code></li>
<li>Bạn có thể thêm chú thích để dễ debug <code>Symbol('ponyfoo')</code></li>
<li>Symbol là hằng định và độc nhất. <code>Symbol(), Symbol(), Symbol('foo') và Symbol('foo')</code> cả 4 giá trị trên khác nhau hoàn toàn.</li>
<li><code>typeof Symbol() === 'symbol'</code></li>
<li>You can also create global symbols with Symbol.for(key)
If a symbol with the provided key already existed, you get that one back
Otherwise, a new symbol is created, using key as its description as well
Symbol.keyFor(symbol) is the inverse function, taking a symbol and returning its key
Global symbols are as global as it gets, or cross-realm. Single registry used to look up these symbols across the runtime
<code>window context</code>
<code>eval context</code>
<code>&lt;iframe&gt; context, Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')</code>
There’s also “well-known” symbols
Not on the global registry, accessible through Symbol[name], e.g: Symbol.iterator
Cross-realm, meaning Symbol.iterator === iframe.contentWindow.Symbol.iterator
Used by specification to define protocols, such as the iterable protocol over Symbol.iterator
They’re not actually well-known – in colloquial terms
Iterating over symbol properties is hard, but not impossible and definitely not private
Symbols are hidden to all pre-ES6 “reflection” methods
Symbols are accessible through Object.getOwnPropertySymbols
You won’t stumble upon them but you will find them if actively looking</li>
</ul>
</article><a href="https://ponyfoo.com/articles/es6" target="_blank" class="Post--translate--M7rYE" data-reactid=".141kppb7qbk.0.3.3.2.0.4"><span data-reactid=".141kppb7qbk.0.3.3.2.0.4.0">Translated from original post by </span><span data-reactid=".141kppb7qbk.0.3.3.2.0.4.1">Pony Foo</span></a><div class="Post--siblingRight--2dUHD" data-reactid=".141kppb7qbk.0.3.3.2.0.6"><a class="" href="/paidverts-ptc/" data-reactid=".141kppb7qbk.0.3.3.2.0.6.0"><span data-reactid=".141kppb7qbk.0.3.3.2.0.6.0.0">PaidVerts - Cuộc cách mạng của Paid to click</span><i class="icon-right-open-big" data-reactid=".141kppb7qbk.0.3.3.2.0.6.0.1"></i></a></div><p class="GitHubEditLink--text--aHUdG" data-reactid=".141kppb7qbk.0.3.3.2.0.7"><span data-reactid=".141kppb7qbk.0.3.3.2.0.7.0">Bài viết sai chính tả? Có điểm chưa rõ ràng?</span><span data-reactid=".141kppb7qbk.0.3.3.2.0.7.1">  </span><a href="https://github.com/thangngoc89/blog-posts/blob/master/es6.md" target="_blank" data-reactid=".141kppb7qbk.0.3.3.2.0.7.2">Sửa bài viết trên Github</a></p><div data-reactid=".141kppb7qbk.0.3.3.2.0.8"><div class="Placeholder--block--1Z27R" style="height:10rem;" data-reactid=".141kppb7qbk.0.3.3.2.0.8.2"><div class="Placeholder--placeholder--2W3lD" data-reactid=".141kppb7qbk.0.3.3.2.0.8.2.0">Loading Disqus...</div></div></div></div></div></div></div><footer class="index--footer--2j-0x" data-reactid=".141kppb7qbk.0.4"><div class="row" data-reactid=".141kppb7qbk.0.4.0"><div class="index--info--1Hx5I" data-reactid=".141kppb7qbk.0.4.0.0"><p data-reactid=".141kppb7qbk.0.4.0.0.0"><span data-reactid=".141kppb7qbk.0.4.0.0.0.0">Built with</span><span class="index--heart--HiWHM" data-reactid=".141kppb7qbk.0.4.0.0.0.1"> ♥ </span><span data-reactid=".141kppb7qbk.0.4.0.0.0.2">by Khoa Nguyen</span></p><p data-reactid=".141kppb7qbk.0.4.0.0.1"><a target="_blank" href="https://github.com/thangngoc89/blog" data-reactid=".141kppb7qbk.0.4.0.0.1.0">Source code available under MIT License</a></p></div><div class="index--copyright--3Je2V" data-reactid=".141kppb7qbk.0.4.0.1"><p data-reactid=".141kppb7qbk.0.4.0.1.0">Copyright©2015-present, Khoa Nguyen</p></div></div></footer></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"\n","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.621d497b9b3643e03358f2d161e79b45.json"},{"title":"Giới thiệu","layout":"Page","description":"Vài điều cơ bản về mình\n\nMình là Khoa\n\nMình học ngành Y\n\nMình thích viết blog và lập trình\n\nLập trình rất vui\n\nHãy như Khoa\n\nNgôn ngữ ?\n\nMình chủ yếu tìm hiểu về viết web.\n\nCác ngôn ngữ mình dùng…","__filename":"about.md","__url":"/about/","__resourceUrl":"/about/index.html","__dataUrl":"/about/index.html.c491930b075324c5239a45665412fa4e.json"},{"title":"Bài viết","layout":"Archive","description":"\n","__filename":"archive.md","__url":"/archive/","__resourceUrl":"/archive/index.html","__dataUrl":"/archive/index.html.a54aadf9cd03f26463ab665192553082.json"},{"layout":"Post","title":"[Black Friday 2014] Namecheap giảm giá Domain/Hosting chỉ còn $0.98","date":"2014-11-27T13:49:22.000Z","tags":["namecheap","domain","black-friday"],"description":"namecheap\n\nHưởng ứng Black Friday năm nay Namecheap đã mang đến cho người dùng coupon giảm giá còn $0.98/năm cho việc thanh toán khi đăng ký hoặc transfer domain các loại.\n\nCác khuyến mãi cụ thể mà…","__filename":"black-friday-2014-namecheap-giam-gia-domainhosting-chi-con-0-98.md","__url":"/black-friday-2014-namecheap-giam-gia-domainhosting-chi-con-0-98/","__resourceUrl":"/black-friday-2014-namecheap-giam-gia-domainhosting-chi-con-0-98/index.html","__dataUrl":"/black-friday-2014-namecheap-giam-gia-domainhosting-chi-con-0-98/index.html.ac2d6341b86c9874d7795998b9eb16d3.json"},{"layout":"Post","title":"[BOT] MultiTools Paidverts & BTCClicks & ProBux v3","date":"2014-11-16T09:48:08.000Z","tags":["mmo","bot"],"description":"MultiTools for Paidverts BTCClicks Probux\n\nMở đầu\n\nTrong bài này mình sẽ hướng dẫn các bạn sử dụng MultiTools của tác giả Bloons97.\n\nĐây là một bot mạnh mẽ được viết trên C# và được tác giả cập nhật…","__filename":"bot-multitools-paidverts-btcclicks-probux-v3.md","__url":"/bot-multitools-paidverts-btcclicks-probux-v3/","__resourceUrl":"/bot-multitools-paidverts-btcclicks-probux-v3/index.html","__dataUrl":"/bot-multitools-paidverts-btcclicks-probux-v3/index.html.ecba6237f2825a312034b59c1ffd5542.json"},{"layout":"Post","title":"Blog mình thường đọc","date":"2015-03-15T06:00:00.000Z","description":"Tập hợp blog mình thích đọc và follow ","tags":["link"],"toc":false,"__filename":"blog-minh-thuong-doc.md","__url":"/blog-minh-thuong-doc/","__resourceUrl":"/blog-minh-thuong-doc/index.html","__dataUrl":"/blog-minh-thuong-doc/index.html.3df1ef9ddd991a34e96847fcbdb72517.json"},{"layout":"Post","title":"Cách xem quảng cáo trên Paidverts","date":"2014-11-15T22:24:03.000Z","tags":["mmo"],"description":"Trong bài trước mình đã Giới thiệu cơ bản về PaidVerts. Trong bài này mình sẽ tiếp tục hướng dẫn cách xem quảng cáo trên PaidVerts.\n\nHướng dẫn xem quảng cáo trên PaidVerts\n\nTruy cập vào https&#x3A…","__filename":"cach-xem-quang-cao-tren-paidverts.md","__url":"/cach-xem-quang-cao-tren-paidverts/","__resourceUrl":"/cach-xem-quang-cao-tren-paidverts/index.html","__dataUrl":"/cach-xem-quang-cao-tren-paidverts/index.html.7370aa93d37d4b6ebc0309df2ebbd852.json"},{"layout":"Post","title":"[Laravel cơ bản] Cài đặt Laravel","date":"2015-01-05T19:36:03.000Z","description":"Cài đặt Laravel - Series Laravel cơ bản","tags":["laravel"],"__filename":"cai-dat-laravel.md","__url":"/cai-dat-laravel/","__resourceUrl":"/cai-dat-laravel/index.html","__dataUrl":"/cai-dat-laravel/index.html.2666df64f2268819bf32bd8afd1f39d2.json"},{"layout":"Post","title":"Cài đặt Node.JS trên Windows","date":"2015-01-05T04:48:11.000Z","tags":["js"],"description":"Hôm qua mình có cài lại máy, kéo theo đó là một số chương trình cho việc lập trình trong đó có NodeJS.\n\nNhưng mà khi cài vào mình phải dùng Node.JS Command Prompt được đi kèm thì mới gọi được lệnh…","__filename":"cai-dat-nodejs-tren-windows.md","__url":"/cai-dat-nodejs-tren-windows/","__resourceUrl":"/cai-dat-nodejs-tren-windows/index.html","__dataUrl":"/cai-dat-nodejs-tren-windows/index.html.84661536238ac61abfcdf89b1810234b.json"},{"layout":"Post","title":"Câu lệnh Bash bạn hay sử dụng","date":"2016-01-26T07:00:00.000Z","tags":["bash"],"toc":false,"description":"Nếu bạn muốn xem các câu lệnh bash được sử dụng nhiều nhất\nhãy gõ lệnh sau vào Terminal (Linux và MacOSX đều chạy):\n\nĐây là danh sách những câu lệnh được dùng nhiều nhất của mình (Linux Mint)\n\nCủa bạn…","__filename":"cau-lenh-bash-duoc-ban-dung-nhieu-nhat.md","__url":"/cau-lenh-bash-duoc-ban-dung-nhieu-nhat/","__resourceUrl":"/cau-lenh-bash-duoc-ban-dung-nhieu-nhat/index.html","__dataUrl":"/cau-lenh-bash-duoc-ban-dung-nhieu-nhat/index.html.c017bcd1ac333472cea44a567ae78ea2.json"},{"layout":"Post","title":"Cài đặt Wine chạy các ứng dụng Windows trên Ubuntu","date":"2014-11-16T13:31:45.000Z","tags":["vps"],"description":"Mở đầu\n\nChắc hẳn các bạn ai cũng biết, giá VPS linux thường rẻ hơn VPS Windows (phí bản quyền) nhưng hầu hết các ứng dụng kiếm tiền (cũng như các ứng dụng cơ bản khác) đều chỉ có thể chạy trên Windows…","__filename":"cai-dat-wine-tren-ubuntu.md","__url":"/cai-dat-wine-tren-ubuntu/","__resourceUrl":"/cai-dat-wine-tren-ubuntu/index.html","__dataUrl":"/cai-dat-wine-tren-ubuntu/index.html.368edf38d58da387a4231e3b0de8d376.json"},{"layout":"Post","title":"Chuyển đổi Blog từ Wordpress sang Ghost","date":"2015-01-07T13:48:54.000Z","tags":["meta"],"toc":false,"description":"Hôm nay mình đã hoàn thành việc chuyển đổi và chính thức sử dụng Ghost cho Blog của mình\n\nGhost : [http://ghost.org]\n\nMột số lí do mình sử dụng Ghost\n\nTrình soạn thảo Markdown thích hợp cho việc viết…","__filename":"chuyen-doi-blog-tu-wordpress-sang-ghost.md","__url":"/chuyen-doi-blog-tu-wordpress-sang-ghost/","__resourceUrl":"/chuyen-doi-blog-tu-wordpress-sang-ghost/index.html","__dataUrl":"/chuyen-doi-blog-tu-wordpress-sang-ghost/index.html.4f9268725c99fef0c1450d2b7be38c3d.json"},{"layout":"Post","title":"Database Seeder - Tạo dummy data - Larask Gist","date":"2015-03-13T17:00:00.000Z","description":"[Series] Larask Gist - Thiết lập Database Seeder , chuẩn bị dummy data","tags":["laravel"],"__filename":"database-seeder-larask-gist.md","__url":"/database-seeder-larask-gist/","__resourceUrl":"/database-seeder-larask-gist/index.html","__dataUrl":"/database-seeder-larask-gist/index.html.cfe20e1d10b58542cca474f560b14c52.json"},{"layout":"Post","title":"Detour - Giới thiệu và sử dụng UUID","date":"2015-03-13T10:00:00.000Z","description":"[Series] Larask Gist - Sử dụng UUID để bảo vệ những thông tin nhạy cảm của ứng dụng","tags":["laravel"],"__filename":"detour-gioi-thieu-va-su-dung-uuid-voi-larask-gist.md","__url":"/detour-gioi-thieu-va-su-dung-uuid-voi-larask-gist/","__resourceUrl":"/detour-gioi-thieu-va-su-dung-uuid-voi-larask-gist/index.html","__dataUrl":"/detour-gioi-thieu-va-su-dung-uuid-voi-larask-gist/index.html.8b1c66f352361b344a629a9548a754b5.json"},{"layout":"Post","title":"DigitalOcean : Cách đăng kí VPS và sử dụng promo code","date":"2014-11-17T10:12:01.000Z","tags":["vps"],"description":"VPS là gì ?\n\nVPS (Vitrual Private Servers) là 1 server ảo có khả năng chạy 24/24 các chương trình mà bạn thiết lập. Bạn có thể chạy các chương trình để kiếm tiền hoặc đặt một website/blog lên đó khi…","__filename":"digitalocean-dang-ki-vps-va-coupon.md","__url":"/digitalocean-dang-ki-vps-va-coupon/","__resourceUrl":"/digitalocean-dang-ki-vps-va-coupon/index.html","__dataUrl":"/digitalocean-dang-ki-vps-va-coupon/index.html.d8001da3c44f080e3095d6edecb12108.json"},{"layout":"Post","title":"@each với Laravel Blade","date":"2015-03-16T10:00:00.000Z","description":"Sử dụng @each trong Laravel Blade để giúp template gọn gàng hơn","tags":["laravel"],"toc":false,"__filename":"each-voi-laravel-blade.md","__url":"/each-voi-laravel-blade/","__resourceUrl":"/each-voi-laravel-blade/index.html","__dataUrl":"/each-voi-laravel-blade/index.html.334aa7949d1596670563583647e9f20d.json"},{"layout":"Post","title":"Tổng quan ES6 qua 350 điểm","date":"2016-02-21T20:20:00.000Z","tags":["js"],"draft":true,"translate":{"url":"https://ponyfoo.com/articles/es6","author":"Pony Foo"},"description":"Giới thiệu\n\nES6, còn được biết với tên Harmony, es-next, ES2015 là bản mô tả mới nhất của Javascript\n\nBản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)\n\nCác bản mô tả tiếp theo…","__filename":"es6.md","__url":"/es6/","__resourceUrl":"/es6/index.html","__dataUrl":"/es6/index.html.dec750c93567f29d43f8c0049af36cf4.json"},{"layout":"Post","title":"Free VPS 7 ngày 2GB RAM Windows Server từ CloudSigma","date":"2014-11-24T21:46:11.000Z","tags":["vps"],"description":"Hiện tại CloudSigma đang có chương trình free trial VPS với các thông số như sau:\n\n2GB RAM\n\nCPU 2GHz\n\nBandwidth 5 GB (vừa đủ để anh em nhà mình chiến hitleap trong 1 tuần)\n\nMình đã tạo cỡ 10 tài khoản…","__filename":"free-vps-7-ngay-2gb-ram-windows-server-cloudsigma.md","__url":"/free-vps-7-ngay-2gb-ram-windows-server-cloudsigma/","__resourceUrl":"/free-vps-7-ngay-2gb-ram-windows-server-cloudsigma/index.html","__dataUrl":"/free-vps-7-ngay-2gb-ram-windows-server-cloudsigma/index.html.2604c42f4119e2915864b1650267ac6a.json"},{"layout":"Post","title":"Giới thiệu Discourse","date":"2014-12-01T17:53:10.000Z","tags":["discourse"],"description":"Discourse là gì?\n\nDiscourse là một dự án mã nguồn mở để xây dựng một nền tảng thảo luận online có thể dùng với các mục đích sau :\n\nDanh sách gửi mail\n\nMột diễn đàn thảo luận\n\nMột chat room\n\nMục tiêu…","__filename":"gioi-thieu-discourse.md","__url":"/gioi-thieu-discourse/","__resourceUrl":"/gioi-thieu-discourse/index.html","__dataUrl":"/gioi-thieu-discourse/index.html.5121bd075aed20f5c2d3cb2d49b80951.json"},{"layout":"Post","title":"Facebook Comment Responsive","date":"2015-01-07T10:16:10.000Z","tags":["css"],"description":"Mặc định thì Facebook Comment không hỗ trợ responsive, tuy nhiên với 1 ít hack với CSS và HTML5, Facebook Comment ngay lập tức sẽ hỗ trợ responsive.\n\nLấy code Facebook Comments\n\nTruy cập vào Facebook…","__filename":"facebook-comment-responsive.md","__url":"/facebook-comment-responsive/","__resourceUrl":"/facebook-comment-responsive/index.html","__dataUrl":"/facebook-comment-responsive/index.html.053760a914ffe592f76a5e5942cb4435.json"},{"layout":"Post","title":"Giới thiệu Series Discourse cơ bản","date":"2015-01-07T08:30:20.000Z","tags":["discourse"],"description":"Discourse là một dự án mã nguồn mở để xây dựng một nền tảng thảo luận online có thể dùng với các mục đích sau :\n\nDanh sách gửi mail\n\nMột diễn đàn thảo luận\n\nMột chat room\n\nMục tiêu của Discourse là…","__filename":"gioi-thieu-series-discourse-co-ban.md","__url":"/gioi-thieu-series-discourse-co-ban/","__resourceUrl":"/gioi-thieu-series-discourse-co-ban/index.html","__dataUrl":"/gioi-thieu-series-discourse-co-ban/index.html.5ddbd5d6cd075dc79a19f70fc0f38a65.json"},{"layout":"Post","title":"Giới thiệu series Larask Gist","date":"2015-03-12T13:00:00.000Z","description":"[Series] Larask Gist - A Laravel 5 Github Clone","tags":["laravel"],"__filename":"gioi-thieu-series-larask-gist.md","__url":"/gioi-thieu-series-larask-gist/","__resourceUrl":"/gioi-thieu-series-larask-gist/index.html","__dataUrl":"/gioi-thieu-series-larask-gist/index.html.3ba8fd5403687bcf6b1c1bd32d7ff0d3.json"},{"layout":"Post","title":"Giới thiệu Series Laravel 4 cơ bản","date":"2015-01-04T14:46:23.000Z","tags":["laravel"],"description":"Giới thiệu Laravel\n\nLaravel là một Framework mã nguồn mở sử mô hình MVC (Model-View-Controller) mạnh mẽ giúp bạn có thể dễ dàng tạo ra các ứng dụng PHP từ đơn giản đến phức tạp nhất một các nhanh…","__filename":"gioi-thieu-series-laravel-4-co-ban.md","__url":"/gioi-thieu-series-laravel-4-co-ban/","__resourceUrl":"/gioi-thieu-series-laravel-4-co-ban/index.html","__dataUrl":"/gioi-thieu-series-laravel-4-co-ban/index.html.28e3cbc6713d18551ff5b7c76c707799.json"},{"layout":"Post","title":"iMacros Omnia3 cắm máy kiếm euro tự động","date":"2014-11-23T10:51:23.000Z","toc":false,"tags":["laravel"],"description":"Update\n\nMình đã ngừng hỗ trợ cho Ommia3 vì nghi vấn scam\n\n* * *\n\nỞ post trước mình đã có giới thiệu sơ lược về Omnia3  sau 1 ngày nghiên cứu thì mình thấy là site này có rate rất cao nên mình đã viết…","__filename":"imacros-omnia3-cam-may-kiem-euro-tu-dong.md","__url":"/imacros-omnia3-cam-may-kiem-euro-tu-dong/","__resourceUrl":"/imacros-omnia3-cam-may-kiem-euro-tu-dong/index.html","__dataUrl":"/imacros-omnia3-cam-may-kiem-euro-tu-dong/index.html.57dc622ceb05750e18c525fff16b5366.json"},{"title":"Khoa Nguyen Blog","layout":"Homepage","description":"\n","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.91fc28acc75f8be50d02def43fbf87e6.json"},{"layout":"Post","title":"json ⊄ js","date":"2016-02-19T23:22:00.000Z","tags":["js","json"],"translate":{"url":"https://medium.com/joys-of-javascript/json-js-42a28471221d#.m23ozaapw","author":"Dan Pupius"},"description":"Mọi người thường nói rằng JSON là một phần nhỏ (subset) của Javascript.\n\nVấn đề là nó không phải như vậy.\n\nDựa vào spec của JSON, một chuỗi có thể chứa bất cứ kí tự unicode nào ngoại trừ \" hoặc / hoặc…","__filename":"json-js.md","__url":"/json-js/","__resourceUrl":"/json-js/index.html","__dataUrl":"/json-js/index.html.458c2f731d5aa41c6fd9f8c8a92f19c7.json"},{"layout":"Post","title":"Kiếm tiền bằng cách rút gọn và chia sẽ link với Oni.vi (10.000 VND/ 1000 view)","date":"2014-11-23T11:50:29.000Z","tags":["mmo"],"description":"Update 12/01/2015\n\nOni.vn hiện tại đã dừng hoạt động\n\n* * *\n\nTƯNG BỪNG KHAI TRƯƠNG NHẬN QUÀ HẤP DẪN\n\n\\[​IMG]\n\nNHẬN NGAY 10.000 VND CHO MỖI 1000 LƯỢT XEM LINK (1 VIEW = 10 VND)\n\n\\[​IMG]\n\n\\[​IMG]  \n\nHỆ…","__filename":"kiem-tien-bang-cach-rut-gon-va-chia-se-link-voi-oni-vn.md","__url":"/kiem-tien-bang-cach-rut-gon-va-chia-se-link-voi-oni-vn/","__resourceUrl":"/kiem-tien-bang-cach-rut-gon-va-chia-se-link-voi-oni-vn/index.html","__dataUrl":"/kiem-tien-bang-cach-rut-gon-va-chia-se-link-voi-oni-vn/index.html.7f4fc175073fad5759d1ed0fbbcb20ea.json"},{"layout":"Post","title":"Laragon - Cài đặt Laravel trong 1 phút","date":"2015-03-11T20:00:00.000Z","description":"Hướng dẫn cài đặt Laragon - Laravel 5/4.2 trong một phút","tags":["laravel"],"__filename":"laragon-cai-dat-laravel-trong-mot-phut.md","__url":"/laragon-cai-dat-laravel-trong-mot-phut/","__resourceUrl":"/laragon-cai-dat-laravel-trong-mot-phut/index.html","__dataUrl":"/laragon-cai-dat-laravel-trong-mot-phut/index.html.a6117934124cb2dc0f470f032b00c077.json"},{"layout":"Post","title":"Cài đặt và thiết lập cơ bản cho Larask Gist","date":"2015-03-12T18:00:00.000Z","description":"Hướng dẫn cài đặt Laravel 5 và thiết lập cơ bản cho ứng dụng","tags":["laravel"],"__filename":"larask-gist-cai-dat-va-cau-hinh-co-ban.md","__url":"/larask-gist-cai-dat-va-cau-hinh-co-ban/","__resourceUrl":"/larask-gist-cai-dat-va-cau-hinh-co-ban/index.html","__dataUrl":"/larask-gist-cai-dat-va-cau-hinh-co-ban/index.html.81560fa67ebffae0cab064aef45f3118.json"},{"layout":"Post","title":"Migration và Model trong Laravel 5 - Larask Gist","date":"2015-03-12T19:00:00.000Z","description":"Hướng dẫn tạo và sử dụng migration trong Laravel 5 - Series Larask Gist","tags":["laravel"],"__filename":"model-va-migration-trong-laravel-5-gist.md","__url":"/model-va-migration-trong-laravel-5-gist/","__resourceUrl":"/model-va-migration-trong-laravel-5-gist/index.html","__dataUrl":"/model-va-migration-trong-laravel-5-gist/index.html.b5c7e58d4374950428dcd9164c421029.json"},{"layout":"Post","title":"Omnia3: Xem video, upload video kiếm tiền","date":"2014-11-22T11:38:32.000Z","tag":["mmo"],"description":"Omina3 là 1 site mới khai trương và còn trong giai đoạn beta cách thức hoạt động site này rất đơn giản. Chỉ cần bạn xem video (tức là xem quảng cáo của nó) thì các bạn sẽ được tiền. Đơn vị tiền tệ sử…","__filename":"omnia3.md","__url":"/omnia3/","__resourceUrl":"/omnia3/index.html","__dataUrl":"/omnia3/index.html.6f5d3f495d4e78960b8ed32765f079b7.json"},{"layout":"Post","title":"PaidVerts - Cuộc cách mạng của Paid to click","date":"2014-11-15T21:44:16.000Z","tags":["mmo"],"description":"Thời gian gần đây, dân chơi MMO đang nóng lên với dịch vụ mới là PaidVerts, dịch vụ được mệnh danh là Cuộc cách mạng của Paid to click chúng ta hãy cùng tìm hiểu về PaidVerts và cách đầu tư để nhanh…","__filename":"paidverts-ptc.md","__url":"/paidverts-ptc/","__resourceUrl":"/paidverts-ptc/index.html","__dataUrl":"/paidverts-ptc/index.html.4fb796a79f4e43bd53650c27a612cfc2.json"},{"layout":"Post","title":"Quản lí các thư viện PHP với Composer","date":"2015-01-03T13:09:22.000Z","tags":["php","composer"],"description":"Update\n\n26/01/2016:\n\nCác bạn có thể dùng prestissimo để tăng tốc độ cài đặt cho Composer (Parallel Composer)\n\nGõ dòng lệnh này vào:\n\ncredit: @VuNhatMinh\n\n* * *\n\nComposer là gì?\n\nVài năm trước, nếu bạn…","__filename":"quan-li-cac-thu-vien-php-voi-composer.md","__url":"/quan-li-cac-thu-vien-php-voi-composer/","__resourceUrl":"/quan-li-cac-thu-vien-php-voi-composer/index.html","__dataUrl":"/quan-li-cac-thu-vien-php-voi-composer/index.html.89ab8ae278209423f1109c8196ca9a92.json"},{"layout":"Post","title":"React.Component với React.createClass","date":"2016-02-19T00:39:00.000Z","tags":["reactjs"],"translate":{"url":"http://reactjsnews.com/composing-components/","author":"Naman Goel & Zach Silveira"},"description":"Giới thiệu\n\nReact hỗ trợ 2 cách để tạo Component.\nBạn có thể kế thừa từ class React.Component hoặc là\ndùng cú pháp cũ React.createClass đã có từ khi React ra đời.\nCó lí do nào cụ thể để dùng một cú…","__filename":"react-component-voi-react-create-class.md","__url":"/react-component-voi-react-create-class/","__resourceUrl":"/react-component-voi-react-create-class/index.html","__dataUrl":"/react-component-voi-react-create-class/index.html.b4647d3db42f8ac1e4a7950ad7bfadbf.json"},{"layout":"Post","title":"React how to","date":"2016-02-20T10:00:00.000Z","tags":["reactjs"],"description":"From react-howto by @petehunt\n\nVietnamese translated by @petehouston\n\nreact-howto\n\nNếu bạn mới làm quen với React (hoặc phần front-end nói chung) thì bạn sẽ thấy hệ sinh thái tương đối khó hiểu. Có…","__filename":"react-howto.md","__url":"/react-howto/","__resourceUrl":"/react-howto/index.html","__dataUrl":"/react-howto/index.html.98e5c90915d8e3c8f22f6c9feb1353db.json"},{"layout":"Post","title":"RunAbove : 6 tháng VPS 2GB RAM Windows miễn phí","date":"2014-11-17T17:38:02.000Z","tags":["vps"],"description":"Giới thiệu RunAbove\n\nRunAbove là CloudVPS sở hữu bởi OVH.\n\nFact: OVH là nhà cung cấp hosting chất lượng đến từ Pháp.\n\nGiá VPS của RunAbove rất cạnh tranh, gói thấp nhất với 2GB RAM và CPU 1 core chỉ…","__filename":"runabove-6-thang-vps-windows-mien-phi.md","__url":"/runabove-6-thang-vps-windows-mien-phi/","__resourceUrl":"/runabove-6-thang-vps-windows-mien-phi/index.html","__dataUrl":"/runabove-6-thang-vps-windows-mien-phi/index.html.a290b016b58b0588c8303c6f6b0192a5.json"},{"layout":"Post","title":"Tạo logo Slack động với CSS3","date":"2016-02-02T19:51:00.000Z","image":"/images/2016/slack-logo/slack-featured.png","tags":["css"],"draft":true,"description":"Demo\n\nSlack & The Logo\n\nSlack là một cái tên khá nổi bây giờ. Slack giúp cho việc giao tiếp giữa\ncác thành viên trong nhóm trở nên dễ dàng hơn. Mình chọn Slack logo để viết bài\nvì Slack logo được dùng…","__filename":"slack-logo-voi-css3.md","__url":"/slack-logo-voi-css3/","__resourceUrl":"/slack-logo-voi-css3/index.html","__dataUrl":"/slack-logo-voi-css3/index.html.d052b597bc831b4969be1e31342134e3.json"},{"layout":"Post","title":"Tạo menu cho Discourse","date":"2015-01-09T00:10:59.000Z","tags":["discourse","css"],"toc":false,"description":"Giới thiệu\n\nCó nhiều bạn hỏi mình về cái menu Discourse của mình. Hôm nay mình sẽ chia sẽ code với các bạn.\nMenu sẽ tự động ản khi bạn trượt xuống nên yên tâm là sẽ không tốn quá nhiều diện tích.\nDemo…","__filename":"tao-menu-cho-discourse.md","__url":"/tao-menu-cho-discourse/","__resourceUrl":"/tao-menu-cho-discourse/index.html","__dataUrl":"/tao-menu-cho-discourse/index.html.d87f7d1052bdcb67cea62957a074a822.json"},{"layout":"Post","title":"Tắt plugin Wordpress khi không vào được Bảng điều khiển","date":"2014-11-16T14:25:54.000Z","tags":["wordpress"],"description":"Hôm qua mình có nghịch với mấy cái plugin WordPress và kết quả là không truy cập vào Bảng điểu khiển (Admin Dashboard) được nữa. Nên chẳng thể nào tắt plugin ấy đi được. Sau một hồi tìm kiếm, mình tìm…","__filename":"tat-plugin-wordpress-thu-cong.md","__url":"/tat-plugin-wordpress-thu-cong/","__resourceUrl":"/tat-plugin-wordpress-thu-cong/index.html","__dataUrl":"/tat-plugin-wordpress-thu-cong/index.html.7f681cb2cb61ca522051720f8a982d1e.json"},{"layout":"Post","title":"Các thuật ngữ MMO thông dụng nhất","date":"2014-11-16T01:27:07.000Z","tags":["mmo"],"description":"Nếu bạn mới bước chân vào việc kiếm tiền online thì chắc hẳn giữa 1 rừng thuật ngữ MMO sẽ làm bạn ngao ngán. Hy vọng bài viết này sẽ giúp bạn phần nào nắm bắt được MMO và tự tin triển khai kế hoạc của…","__filename":"thuat-ngu-mmo.md","__url":"/thuat-ngu-mmo/","__resourceUrl":"/thuat-ngu-mmo/index.html","__dataUrl":"/thuat-ngu-mmo/index.html.608e36b9fd73a865f2554f0eb00f4fa4.json"},{"layout":"Post","title":"Tìm hiểu định dạng MDict (MDD/MDX)","date":"2016-04-05T07:00:00.000Z","route":"tim-hieu-dinh-dang-mdict","tags":["algorithm"],"toc":false,"description":"MDict là một phần mềm đọc tự điển cho định dạng MDD và MDX (cũng do MDict tạo ra) với khả năng tra những danh mục từ điển hàng nghìn từ một cách siêu nhanh và đã rất nổi tiếng từ thời Window Mobile…","__filename":"tim-hieu-dinh-dang-mdict/index.md","__url":"/tim-hieu-dinh-dang-mdict/","__resourceUrl":"/tim-hieu-dinh-dang-mdict/index.html","__dataUrl":"/tim-hieu-dinh-dang-mdict/index.html.821a8fe080e52da8a4466503f2f1f218.json"},{"layout":"Post","title":"Mô hình MVC là gì?","date":"2015-01-04T19:58:21.000Z","tags":["mvc"],"description":"Nếu bạn là một lập trình viên, nhất là lập trình web, sẽ rất khó để bạn có thể xin được việc nếu không biết mô hình MVC. Trong post này mình sẽ trình bày đến các bạn mô hình MVC là gì theo cách hiểu…","__filename":"tim-hieu-mo-hinh-mvc-la-gi.md","__url":"/tim-hieu-mo-hinh-mvc-la-gi/","__resourceUrl":"/tim-hieu-mo-hinh-mvc-la-gi/index.html","__dataUrl":"/tim-hieu-mo-hinh-mvc-la-gi/index.html.06c61b881e3cfa4d7ebd68d4ca22def4.json"},{"layout":"Post","title":"[Video] RunAbove : Kích hoạt Remote Desktop","date":"2014-11-21T07:34:20.000Z","tags":["vps"],"description":"Mặc định thì trên 1 tài khoản mới và VPS mới tạo thì Remote Desktop không được kích. Điều này gây khó khăn cho một số bạn. Bài viết này mình sẽ hướng dẫn cách kích hoạt Remote Desktop trên RunAbove…","__filename":"video-runabove-kich-hoat-remote-desktop.md","__url":"/video-runabove-kich-hoat-remote-desktop/","__resourceUrl":"/video-runabove-kich-hoat-remote-desktop/index.html","__dataUrl":"/video-runabove-kich-hoat-remote-desktop/index.html.64ae06d3e2f23bc06493d2dec605de13.json"},{"layout":"Post","title":"Xóa tất cả table trong database MySQL","date":"2015-03-15T08:00:00.000Z","description":"MySQL Procedure giúp xóa nhanh tất cả table trong 1 database","tags":["mysql"],"toc":false,"__filename":"xoa-tat-ca-cac-table-mysql.md","__url":"/xoa-tat-ca-cac-table-mysql/","__resourceUrl":"/xoa-tat-ca-cac-table-mysql/index.html","__dataUrl":"/xoa-tat-ca-cac-table-mysql/index.html.1d5c817823da676285785c5e3d227071.json"}];window.__INITIAL_STATE__ = {"pages":{"/es6/":{"head":{"layout":"Post","title":"Tổng quan ES6 qua 350 điểm","date":"2016-02-21T20:20:00.000Z","tags":["js"],"draft":true,"translate":{"url":"https://ponyfoo.com/articles/es6","author":"Pony Foo"},"description":"Giới thiệu\n\nES6, còn được biết với tên Harmony, es-next, ES2015 là bản mô tả mới nhất của Javascript\n\nBản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)\n\nCác bản mô tả tiếp theo…"},"body":"<h1 id=\"Gioi-thieu\"><a class=\"markdownIt-Anchor\" href=\"#Gioi-thieu\">#</a> Giới thiệu</h1>\n<ul>\n<li>\n<p>ES6, còn được biết với tên Harmony, <code>es-next</code>, ES2015 là bản mô tả mới nhất của Javascript</p>\n</li>\n<li>\n<p>Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)</p>\n</li>\n<li>\n<p>Các bản mô tả tiếp theo của Javascript sẽ được đặt tên theo dạng ES[YYYY], ví dụ ES2016 cho ES7</p>\n<ul>\n<li>Sẽ cập nhật mỗi năm, tính năng nào không hoàn thành sẽ bị hoãn lại tới năm tiếp theo</li>\n<li>Vì ES6 được bắt đầu trước khi cách gọi mới này ra đời nên chúng ta vẫn thường gọi là ES6</li>\n<li>Bắt đầu từ ES2016 (ES7), chúng ta nên bắt đầu dùng dạng ES[YYYY] để gọi tên phiên bản Javascript.</li>\n<li>Lý do quan trọng nhất khi đặt tên như vậy là để gây áp lực, và buộc các trình duyệt phải thêm tính năng mới vào nhanh hơn.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Cong-cu\"><a class=\"markdownIt-Anchor\" href=\"#Cong-cu\">#</a> Công cụ</h1>\n<ul>\n<li>\n<p>Để làm việc với ES6 ngay từ bây giờ, bạn cần transpiler <strong>Javascript-to-Javascript</strong></p>\n</li>\n<li>\n<p>Transpiler có chức năng</p>\n<ul>\n<li>Biên dịch code của bạn từ phiên bản mới nhất (của Javascript) về phiên bản cũ hơn</li>\n<li>Khi mà trình duyệt đã tương thích với phiên bản mới, chúng ta sẽ biên dịch từ ES2016 và ES2017 về ES6, … và tiếp tục như vậy.</li>\n<li>Hỗ trợ source map</li>\n<li>Bạn có thể tự tin viết code ES6 và dùng trong thực tế ngay từ bây giờ (tuy nhiên, trình duyệt sẽ nhận được code ES5)</li>\n</ul>\n</li>\n<li>\n<p>Babel (một transpiler) có một tính năng mà không có đối thủ nào cạnh tranh được: xuất ra code mà bạn <strong>có thể đọc được</strong></p>\n<ul>\n<li>Dùng <code>babel</code> để biên dịch ES6 xuống ES5</li>\n<li>Dùng <code>babelify</code> kết hợp với <code>babel</code> cùng với Gulp, Grunt, hoặc npm run trong khi build.</li>\n<li>Dùng Node.js v4.x.x sẽ có native support cho ES6 (:+1: cho V8)</li>\n<li>Dùng <code>babel-node</code> với bất kì phiên bản node nào, sẽ biên dịch module xuống ES5</li>\n<li>Babel có một kho plugins và hệ sinh thái phong phú.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Destructuring\"><a class=\"markdownIt-Anchor\" href=\"#Destructuring\">#</a> Destructuring</h1>\n<ul>\n<li>\n<p><code>var {foo} = pony</code> tương đượng với <code>var foo = pony.foo</code></p>\n</li>\n<li>\n<p><code>var {foo: baz} = pony</code> tương đương với <code>var baz = pony.foo</code></p>\n</li>\n<li>\n<p>Bạn có thể cung cấp giá trị mặc định , <code>var {foo='bar'} = baz</code> cho ra <code>foo: 'bar'</code> nếu <code>baz.foo === undefined</code></p>\n</li>\n<li>\n<p>Bạn có thể lấy bao nhiêu giá trị tùy thích <code>var {foo, bar: baz} = {foo: 0, bar: 1}</code> cho ra <code>foo: 0</code> và <code>baz: 1</code></p>\n</li>\n<li>\n<p>Bạn có thể lấy giá trị lồng vào nhau. <code>var {foo: {bar}} = { foo: { bar: 'baz' } }</code> cho ra  <code>bar: 'baz'</code></p>\n</li>\n<li>\n<p>Bạn cũng có thể đặt tên cho nó. <code>var {foo: {bar: deep}} = { foo: { bar: 'baz' } }</code> cho ra <code>deep: 'baz'</code></p>\n</li>\n<li>\n<p>Thuộc tính không tình thấy sẽ cho ra <code>undefined</code> như bình thường. Ví dụ <code>var {foo} = {}</code></p>\n</li>\n<li>\n<p>Giá trị lồng vào nhau không tồn tại sẽ cho ra lỗi, ví dụ: <code>var {foo: {bar}} = {}</code></p>\n</li>\n<li>\n<p>Mảng cũng tương tự, <code>[a, b] = [0, 1]</code> cho ra <code>a: 0</code> và <code>b: 1</code></p>\n</li>\n<li>\n<p>Bạn có thể bỏ qua các giá trị trong mảng, <code>[a, , b] = [0, 1, 2]</code>, cho ra <code>a: 0</code> và <code>b: 2</code></p>\n</li>\n<li>\n<p>Bạn có thể thay đổi vị trí mà không cần biết trung gian <code>[a, b] = [b, a]</code></p>\n</li>\n<li>\n<p>Bạn cũng có thể destruct các tham số của hàm</p>\n<ul>\n<li>Gán giá trị mặc định cho hàm <code>function foo (bar=2) {}</code></li>\n<li>Giá trị mặc định cũng có thể là object <code>function foo (bar={ a: 1, b: 2 }) {}</code></li>\n<li>Chúng ta có thể destruct biến <code>bar</code> ở trên hoàn toàn thế này <code>function foo ({ a=1, b=2 }) {}</code></li>\n<li>Hoặc có thể đặt giá trị mặt định là một object rỗng nếu như không có bất kì tham số nào <code>function foo ({ a=1, b=2 } = {}) {}</code></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Spread-Operator-and-Rest-Parameters\"><a class=\"markdownIt-Anchor\" href=\"#Spread-Operator-and-Rest-Parameters\">#</a> Spread Operator and Rest Parameters</h1>\n<ul>\n<li>\n<p>Rest Parameters (tạm dịch là các tham số còn lại) sẽ <code>arguments</code> tốt hơn</p>\n<ul>\n<li>Bạn có thể định nghĩa nó trong hàm thế này <code>function foo (...everything) {}</code></li>\n<li><code>everything</code> là một mảng gồm tất cả tham số được gửi đến hàm <code>foo</code></li>\n<li>Bạn có thể đặt tên cho vài tham số trước <code>...everything</code> thế này <code>function foo (bar, ...rest) {}</code></li>\n<li>Các tham số đã được đặt tên sẽ được loại ra khỏi <code>...rest</code></li>\n<li><code>...rest</code> phải là tham số cuối cùng trong danh sách</li>\n</ul>\n</li>\n<li>\n<p>Spread operator giống như là ma thuật, nó cũng có cú pháp <code>...</code></p>\n<ul>\n<li>Không cần dùng <code>.apply</code> khi gọi method, <code>fn(...[1, 2, 3])</code> tương đương với <code>fn(1, 2, 3)</code></li>\n<li>Dễ gộp mạng hơn <code>[1, 2, ...[3, 4, 5], 6, 7]</code></li>\n<li>Chuyển đổi các biến dạng mảng hoặc <code>iterable</code> thành mảng, ví dụ: <code>[...document.querySelectorAll('img')]</code></li>\n<li>Có thể dùng khi destruct, <code>[a, , ...rest] = [1, 2, 3, 4, 5]</code> cho ra <code>a: 1</code> và <code>rest: [3, 4, 5]</code></li>\n<li>Cần thiết khi dùng <code>new Date</code> thế này <code>new Date(...[2015, 31, 8])</code></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Arrow-function\"><a class=\"markdownIt-Anchor\" href=\"#Arrow-function\">#</a> Arrow function</h1>\n<ul>\n<li>\n<p>Tạo hàm nhanh chóng thế này <code>param =&gt; returnValue</code></p>\n</li>\n<li>\n<p>Hữu ích khi lập trình hàm (funtional programing) <code>[1, 2].map(x =&gt; x * 2)</code></p>\n</li>\n<li>\n<p>Có nhiều cách để dùng, có thể làm bạn rối lúc đầu</p>\n<ul>\n<li><code>p1 =&gt; expr</code> khi chỉ có một tham số</li>\n<li><code>p1 =&gt; expr</code> có nghĩa là hàm sẽ trả về kết quả <code>expr</code></li>\n<li>Để trả về một object, đặt nó trong một cặp ngoặc <code>() =&gt; ({ foo: 'bar' })</code> nếu không sẽ bị lỗi cú pháp</li>\n<li>Cặp ngoặc có thể dùng khi bạn có không, một, hai hoặc nhiều tham số hơn <code>() =&gt; expr or (p1, p2) =&gt; expr</code></li>\n<li>Cặp ngoặc bên phải có nghĩa là khối code có thể có nhiều dòng <code>() =&gt; {}</code></li>\n<li>Khi bạn dùng khối code, sẽ không có <code>return</code> tự động, bạn phải thêm vào như mọi khi <code>() =&gt; { return 'foo' }</code></li>\n</ul>\n</li>\n<li>\n<p>You can’t name arrow functions statically, but runtimes are now much better at inferring names for most methods.</p>\n</li>\n<li>\n<p>Scope trong arrow function chính là scope của chính arrow function</p>\n<ul>\n<li><code>this</code> trong arrow function sẽ giống với <code>this</code> ở parent scope.</li>\n<li><code>this</code> không thể thay đổi bằng <code>.call</code>, <code>.apply</code>, hoặc là các phương thức tương tự.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Xem thêm: [<a href=\"http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function\">http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function</a>]</p>\n</blockquote>\n<h1 id=\"Template-Literals\"><a class=\"markdownIt-Anchor\" href=\"#Template-Literals\">#</a> Template Literals</h1>\n<ul>\n<li>\n<p>Bạn có thể định nghĩa chuỗi với dấu <code>`</code> (backtick), thay vì kiểu cũ là <code>&quot;</code> và <code>'</code></p>\n</li>\n<li>\n<p>Chuỗi mà bao trong dấu backtick gọi là template literals</p>\n</li>\n<li>\n<p>Template literals có thể gồm nhiều dòng</p>\n</li>\n<li>\n<p>Template literals cho phép bạn đặt biến vào thế này <code>khoanguyen.me is ${rating}</code> (với <code>rating</code> là một biến)</p>\n</li>\n<li>\n<p>Bạn có thể đặt vào bất cứ thứ gì hợp lệ với Javascript trong cặp ngoặc như <code>${2 * 3}</code> hoặc <code>${foo()}</code></p>\n</li>\n<li>\n<p>Bạn có thể thay đổi kết quả kết template literals</p>\n<ul>\n<li>Thêm vào trước <code>fn</code> thế này ``fn`foo, ${bar} and ${baz}```</li>\n<li><code>fn</code> sẽ được gọi với tham số  <code>template, ...expressions</code></li>\n<li><code>template</code> là <code>['foo, ', ' and ', '']</code> và <code>expressions</code> là <code>[bar, baz]</code></li>\n<li>Kết quả trả về của <code>fn</code> sẽ trở thành giá trị của template literal.</li>\n</ul>\n</li>\n<li>\n<p>Tổng kết lại thì định nghĩa chuỗi với template literals tốt hơn so với việc dùng cặp nháy đơn hay nháy kép</p>\n</li>\n</ul>\n<h1 id=\"Object-Literals\"><a class=\"markdownIt-Anchor\" href=\"#Object-Literals\">#</a> Object Literals</h1>\n<ul>\n<li>Thay vì phải viết <code>{ foo: foo }</code>, bây giờ bạn chỉ cần viết  <code>{ foo }</code> – đây được gọi <em>property value shorthand</em> (tạm dịch: định nhanh giá trị của thuộc tính)</li>\n<li>Tính toán tên thuộc tính (<em>Computed property names</em>), <code>{ [prefix + 'Foo']: 'bar' }</code>, khi <code>prefix: 'moz'</code>, sẽ cho ra kết quả <code>{ mozFoo: 'bar' }</code></li>\n<li>Bạn không thể kết hợp computed property names và property value shorthands, <code>{ [foo] }</code> là không hợp lệ</li>\n<li>Bạn có thể định method cho object literal bằng cú pháp nhanh này: <code>{ foo () {} }</code></li>\n</ul>\n<h1 id=\"Class\"><a class=\"markdownIt-Anchor\" href=\"#Class\">#</a> Class</h1>\n<ul>\n<li>Không phải là class như OOP, chỉ là một cú pháp gọn hơn dựa trên prototype</li>\n<li>Cú pháp giống như định object <code>class Foo {}</code></li>\n<li>Instance methods – <code>new Foo().bar</code> – được định nghĩa nhờ cú pháp <em>object literal</em> như trên <code>class Foo { bar () {} }</code></li>\n<li>Static methods – <code>Foo.isPonyFoo()</code> – cần thêm <code>static</code> vào trước, <code>class Foo { static isPonyFoo () {} }</code></li>\n<li>Constructor  <code>class Foo { constructor () { /* initialize instance */ } }</code></li>\n<li>Thừa kế nhờ cấu trúc thế này <code>class PonyFoo extends Foo {}</code></li>\n</ul>\n<h1 id=\"Let-va-Const\"><a class=\"markdownIt-Anchor\" href=\"#Let-va-Const\">#</a> Let và Const</h1>\n<ul>\n<li>\n<p><code>let</code> và <code>const</code> là hai cách khác ngoài <code>var</code> để khởi tạo biến.</p>\n</li>\n<li>\n<p><code>let</code> là <code>block-scoped</code> thay vì <code>lexically scoped</code> như hàm.</p>\n</li>\n<li>\n<p><code>let</code> gắn với <code>block</code> hiện tại, trong khi <code>var</code> gắn với <code>block</code> của hàm</p>\n</li>\n<li>\n<p>“Temporal Dead Zone” (gọi tắt TDZ)</p>\n<ul>\n<li>Bắt đầu ở <code>block</code> mà <code>let foo</code> được khởi tạo</li>\n<li>Kết thúc khi thực hiện câu lệnh khởi tạo <code>let foo</code></li>\n<li>Cố gắng truy cập hoặc gán biến trong vùng TDZ (tức là trước câu lên <code>let foo</code>) sẽ gây ra lỗi</li>\n<li>Giúp tránh các lỗi đau đầu khi biến bị thay đổi trước khi nó được khởi tạo (có thể hiểu như là <code>&quot;use strict&quot;</code>)</li>\n</ul>\n</li>\n<li>\n<p><code>const</code> cũng là <code>block-scoped</code> gắn và ràng buộc bởi TDZ</p>\n</li>\n<li>\n<p>Khi dùng <code>const</code>, biến cần phải gắn giá trị ngay khi khởi tạo <code>const foo = 'bar'</code></p>\n</li>\n<li>\n<p>Gán giá trị cho <code>const</code> sau khi khởi tạo sẽ gây lỗi một ách im lặng hay <code>throw</code> trong <code>&quot;use strict&quot;</code>.</p>\n</li>\n<li>\n<p>Giá trị của biến <code>const</code> không phải là hằng định (immutable)</p>\n<ul>\n<li><code>const foo = { bar: 'baz' }; foo.bar = 'boo'</code> sẽ không <code>throw</code> lỗi</li>\n</ul>\n</li>\n<li>\n<p>Khởi tạo biến cùng tên sẽ <code>throw</code> lỗi</p>\n</li>\n<li>\n<p>Định tạo ra để khắc phục vấn đề ghi đè biến.</p>\n</li>\n</ul>\n<h1 id=\"Symbol\"><a class=\"markdownIt-Anchor\" href=\"#Symbol\">#</a> Symbol</h1>\n<ul>\n<li>Một kiểu dữ liệu mới của ES6</li>\n<li>Bạn có thể khởi tạo symbol thế này <code>var symbol = Symbol()</code></li>\n<li>Bạn có thể thêm chú thích để dễ debug <code>Symbol('ponyfoo')</code></li>\n<li>Symbol là hằng định và độc nhất. <code>Symbol(), Symbol(), Symbol('foo') và Symbol('foo')</code> cả 4 giá trị trên khác nhau hoàn toàn.</li>\n<li><code>typeof Symbol() === 'symbol'</code></li>\n<li>You can also create global symbols with Symbol.for(key)\nIf a symbol with the provided key already existed, you get that one back\nOtherwise, a new symbol is created, using key as its description as well\nSymbol.keyFor(symbol) is the inverse function, taking a symbol and returning its key\nGlobal symbols are as global as it gets, or cross-realm. Single registry used to look up these symbols across the runtime\n<code>window context</code>\n<code>eval context</code>\n<code>&lt;iframe&gt; context, Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')</code>\nThere’s also “well-known” symbols\nNot on the global registry, accessible through Symbol[name], e.g: Symbol.iterator\nCross-realm, meaning Symbol.iterator === iframe.contentWindow.Symbol.iterator\nUsed by specification to define protocols, such as the iterable protocol over Symbol.iterator\nThey’re not actually well-known – in colloquial terms\nIterating over symbol properties is hard, but not impossible and definitely not private\nSymbols are hidden to all pre-ES6 “reflection” methods\nSymbols are accessible through Object.getOwnPropertySymbols\nYou won’t stumble upon them but you will find them if actively looking</li>\n</ul>\n","rawBody":"\n# Giới thiệu\n\n- ES6, còn được biết với tên Harmony, `es-next`, ES2015 là bản mô tả mới nhất của Javascript\n- Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)\n- Các bản mô tả tiếp theo của Javascript sẽ được đặt tên theo dạng ES[YYYY], ví dụ ES2016 cho ES7\n\n  - Sẽ cập nhật mỗi năm, tính năng nào không hoàn thành sẽ bị hoãn lại tới năm tiếp theo\n  - Vì ES6 được bắt đầu trước khi cách gọi mới này ra đời nên chúng ta vẫn thường gọi là ES6\n  - Bắt đầu từ ES2016 (ES7), chúng ta nên bắt đầu dùng dạng ES[YYYY] để gọi tên phiên bản Javascript.\n  - Lý do quan trọng nhất khi đặt tên như vậy là để gây áp lực, và buộc các trình duyệt phải thêm tính năng mới vào nhanh hơn.\n\n# Công cụ\n\n- Để làm việc với ES6 ngay từ bây giờ, bạn cần transpiler **Javascript-to-Javascript**\n- Transpiler có chức năng\n\n  - Biên dịch code của bạn từ phiên bản mới nhất (của Javascript) về phiên bản cũ hơn\n  - Khi mà trình duyệt đã tương thích với phiên bản mới, chúng ta sẽ biên dịch từ ES2016 và ES2017 về ES6, ... và tiếp tục như vậy.\n  - Hỗ trợ source map\n  - Bạn có thể tự tin viết code ES6 và dùng trong thực tế ngay từ bây giờ (tuy nhiên, trình duyệt sẽ nhận được code ES5)\n\n- Babel (một transpiler) có một tính năng mà không có đối thủ nào cạnh tranh được: xuất ra code mà bạn **có thể đọc được**\n\n  - Dùng `babel` để biên dịch ES6 xuống ES5\n  - Dùng `babelify` kết hợp với `babel` cùng với Gulp, Grunt, hoặc npm run trong khi build.\n  - Dùng Node.js v4.x.x sẽ có native support cho ES6 (:+1: cho V8)\n  - Dùng `babel-node` với bất kì phiên bản node nào, sẽ biên dịch module xuống ES5\n  - Babel có một kho plugins và hệ sinh thái phong phú.\n\n# Destructuring\n\n- `var {foo} = pony` tương đượng với `var foo = pony.foo`\n- `var {foo: baz} = pony` tương đương với `var baz = pony.foo`\n- Bạn có thể cung cấp giá trị mặc định , `var {foo='bar'} = baz` cho ra `foo: 'bar'` nếu `baz.foo === undefined`\n- Bạn có thể lấy bao nhiêu giá trị tùy thích `var {foo, bar: baz} = {foo: 0, bar: 1}` cho ra `foo: 0` và `baz: 1`\n- Bạn có thể lấy giá trị lồng vào nhau. `var {foo: {bar}} = { foo: { bar: 'baz' } }` cho ra  `bar: 'baz'`\n- Bạn cũng có thể đặt tên cho nó. `var {foo: {bar: deep}} = { foo: { bar: 'baz' } }` cho ra `deep: 'baz'`\n- Thuộc tính không tình thấy sẽ cho ra `undefined` như bình thường. Ví dụ `var {foo} = {}`\n- Giá trị lồng vào nhau không tồn tại sẽ cho ra lỗi, ví dụ: `var {foo: {bar}} = {}`\n- Mảng cũng tương tự, `[a, b] = [0, 1]` cho ra `a: 0` và `b: 1`\n- Bạn có thể bỏ qua các giá trị trong mảng, `[a, , b] = [0, 1, 2]`, cho ra `a: 0` và `b: 2`\n- Bạn có thể thay đổi vị trí mà không cần biết trung gian `[a, b] = [b, a]`\n- Bạn cũng có thể destruct các tham số của hàm\n\n  - Gán giá trị mặc định cho hàm `function foo (bar=2) {}`\n  - Giá trị mặc định cũng có thể là object `function foo (bar={ a: 1, b: 2 }) {}`\n  - Chúng ta có thể destruct biến `bar` ở trên hoàn toàn thế này `function foo ({ a=1, b=2 }) {}`\n  - Hoặc có thể đặt giá trị mặt định là một object rỗng nếu như không có bất kì tham số nào `function foo ({ a=1, b=2 } = {}) {}`\n\n# Spread Operator and Rest Parameters\n\n- Rest Parameters (tạm dịch là các tham số còn lại) sẽ `arguments` tốt hơn\n\n  - Bạn có thể định nghĩa nó trong hàm thế này `function foo (...everything) {}`\n  - `everything` là một mảng gồm tất cả tham số được gửi đến hàm `foo`\n  - Bạn có thể đặt tên cho vài tham số trước `...everything` thế này `function foo (bar, ...rest) {}`\n  - Các tham số đã được đặt tên sẽ được loại ra khỏi `...rest`\n  - `...rest` phải là tham số cuối cùng trong danh sách\n- Spread operator giống như là ma thuật, nó cũng có cú pháp `...`\n\n  - Không cần dùng `.apply` khi gọi method, `fn(...[1, 2, 3])` tương đương với `fn(1, 2, 3)`\n  - Dễ gộp mạng hơn `[1, 2, ...[3, 4, 5], 6, 7]`\n  - Chuyển đổi các biến dạng mảng hoặc `iterable` thành mảng, ví dụ: `[...document.querySelectorAll('img')]`\n  - Có thể dùng khi destruct, `[a, , ...rest] = [1, 2, 3, 4, 5]` cho ra `a: 1` và `rest: [3, 4, 5]`\n  - Cần thiết khi dùng `new Date` thế này `new Date(...[2015, 31, 8])`\n\n# Arrow function\n\n- Tạo hàm nhanh chóng thế này `param => returnValue`\n- Hữu ích khi lập trình hàm (funtional programing) `[1, 2].map(x => x * 2)`\n- Có nhiều cách để dùng, có thể làm bạn rối lúc đầu\n\n  - `p1 => expr` khi chỉ có một tham số\n  - `p1 => expr` có nghĩa là hàm sẽ trả về kết quả `expr`\n  - Để trả về một object, đặt nó trong một cặp ngoặc `() => ({ foo: 'bar' })` nếu không sẽ bị lỗi cú pháp\n  - Cặp ngoặc có thể dùng khi bạn có không, một, hai hoặc nhiều tham số hơn `() => expr or (p1, p2) => expr`\n  - Cặp ngoặc bên phải có nghĩa là khối code có thể có nhiều dòng `() => {}`\n  - Khi bạn dùng khối code, sẽ không có `return` tự động, bạn phải thêm vào như mọi khi `() => { return 'foo' }`\n- You can’t name arrow functions statically, but runtimes are now much better at inferring names for most methods.\n- Scope trong arrow function chính là scope của chính arrow function\n\n  - `this` trong arrow function sẽ giống với `this` ở parent scope.\n  - `this` không thể thay đổi bằng `.call`, `.apply`, hoặc là các phương thức tương tự.\n\n> Xem thêm: [http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function]\n\n# Template Literals\n\n- Bạn có thể định nghĩa chuỗi với dấu `` ` `` (backtick), thay vì kiểu cũ là `\"` và `'`\n- Chuỗi mà bao trong dấu backtick gọi là template literals\n- Template literals có thể gồm nhiều dòng\n- Template literals cho phép bạn đặt biến vào thế này `khoanguyen.me is ${rating}` (với `rating` là một biến)\n- Bạn có thể đặt vào bất cứ thứ gì hợp lệ với Javascript trong cặp ngoặc như `${2 * 3}` hoặc `${foo()}`\n- Bạn có thể thay đổi kết quả kết template literals\n\n  - Thêm vào trước `fn` thế này ``fn`foo, ${bar} and ${baz}```\n  - `fn` sẽ được gọi với tham số  `template, ...expressions`\n  - `template` là `['foo, ', ' and ', '']` và `expressions` là `[bar, baz]`\n  - Kết quả trả về của `fn` sẽ trở thành giá trị của template literal.\n- Tổng kết lại thì định nghĩa chuỗi với template literals tốt hơn so với việc dùng cặp nháy đơn hay nháy kép\n\n# Object Literals\n\n- Thay vì phải viết `{ foo: foo }`, bây giờ bạn chỉ cần viết  `{ foo }` – đây được gọi *property value shorthand* (tạm dịch: định nhanh giá trị của thuộc tính)\n- Tính toán tên thuộc tính (*Computed property names*), `{ [prefix + 'Foo']: 'bar' }`, khi `prefix: 'moz'`, sẽ cho ra kết quả `{ mozFoo: 'bar' }`\n- Bạn không thể kết hợp computed property names và property value shorthands, `{ [foo] }` là không hợp lệ\n- Bạn có thể định method cho object literal bằng cú pháp nhanh này: `{ foo () {} }`\n\n# Class\n\n- Không phải là class như OOP, chỉ là một cú pháp gọn hơn dựa trên prototype\n- Cú pháp giống như định object `class Foo {}`\n- Instance methods – `new Foo().bar` – được định nghĩa nhờ cú pháp *object literal* như trên `class Foo { bar () {} }`\n- Static methods – `Foo.isPonyFoo()` – cần thêm `static` vào trước, `class Foo { static isPonyFoo () {} }`\n- Constructor  `class Foo { constructor () { /* initialize instance */ } }`\n- Thừa kế nhờ cấu trúc thế này `class PonyFoo extends Foo {}`\n\n# Let và Const\n\n- `let` và `const` là hai cách khác ngoài `var` để khởi tạo biến.\n- `let` là `block-scoped` thay vì `lexically scoped` như hàm.\n- `let` gắn với `block` hiện tại, trong khi `var` gắn với `block` của hàm\n- “Temporal Dead Zone” (gọi tắt TDZ)\n\n  - Bắt đầu ở `block` mà `let foo` được khởi tạo\n  - Kết thúc khi thực hiện câu lệnh khởi tạo `let foo`\n  - Cố gắng truy cập hoặc gán biến trong vùng TDZ (tức là trước câu lên `let foo`) sẽ gây ra lỗi\n  - Giúp tránh các lỗi đau đầu khi biến bị thay đổi trước khi nó được khởi tạo (có thể hiểu như là `\"use strict\"`)\n- `const` cũng là `block-scoped` gắn và ràng buộc bởi TDZ\n- Khi dùng `const`, biến cần phải gắn giá trị ngay khi khởi tạo `const foo = 'bar'`\n- Gán giá trị cho `const` sau khi khởi tạo sẽ gây lỗi một ách im lặng hay `throw` trong `\"use strict\"`.\n- Giá trị của biến `const` không phải là hằng định (immutable)\n\n  - `const foo = { bar: 'baz' }; foo.bar = 'boo'` sẽ không `throw` lỗi\n- Khởi tạo biến cùng tên sẽ `throw` lỗi\n- Định tạo ra để khắc phục vấn đề ghi đè biến.\n\n# Symbol\n\n- Một kiểu dữ liệu mới của ES6\n- Bạn có thể khởi tạo symbol thế này `var symbol = Symbol()`\n- Bạn có thể thêm chú thích để dễ debug `Symbol('ponyfoo')`\n- Symbol là hằng định và độc nhất. `Symbol(), Symbol(), Symbol('foo') và Symbol('foo')` cả 4 giá trị trên khác nhau hoàn toàn.\n- `typeof Symbol() === 'symbol'`\n- You can also create global symbols with Symbol.for(key)\nIf a symbol with the provided key already existed, you get that one back\nOtherwise, a new symbol is created, using key as its description as well\nSymbol.keyFor(symbol) is the inverse function, taking a symbol and returning its key\nGlobal symbols are as global as it gets, or cross-realm. Single registry used to look up these symbols across the runtime\n`window context`\n`eval context`\n`<iframe> context, Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')`\nThere’s also “well-known” symbols\nNot on the global registry, accessible through Symbol[name], e.g: Symbol.iterator\nCross-realm, meaning Symbol.iterator === iframe.contentWindow.Symbol.iterator\nUsed by specification to define protocols, such as the iterable protocol over Symbol.iterator\nThey’re not actually well-known – in colloquial terms\nIterating over symbol properties is hard, but not impossible and definitely not private\nSymbols are hidden to all pre-ES6 “reflection” methods\nSymbols are accessible through Object.getOwnPropertySymbols\nYou won’t stumble upon them but you will find them if actively looking\n","raw":"---\nlayout: Post\ntitle: \"Tổng quan ES6 qua 350 điểm\"\ndate: 2016-02-21 20:20:00\ntags: [js]\ndraft: true\ntranslate:\n  url: \"https://ponyfoo.com/articles/es6\"\n  author: \"Pony Foo\"\n---\n\n# Giới thiệu\n\n- ES6, còn được biết với tên Harmony, `es-next`, ES2015 là bản mô tả mới nhất của Javascript\n- Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)\n- Các bản mô tả tiếp theo của Javascript sẽ được đặt tên theo dạng ES[YYYY], ví dụ ES2016 cho ES7\n\n  - Sẽ cập nhật mỗi năm, tính năng nào không hoàn thành sẽ bị hoãn lại tới năm tiếp theo\n  - Vì ES6 được bắt đầu trước khi cách gọi mới này ra đời nên chúng ta vẫn thường gọi là ES6\n  - Bắt đầu từ ES2016 (ES7), chúng ta nên bắt đầu dùng dạng ES[YYYY] để gọi tên phiên bản Javascript.\n  - Lý do quan trọng nhất khi đặt tên như vậy là để gây áp lực, và buộc các trình duyệt phải thêm tính năng mới vào nhanh hơn.\n\n# Công cụ\n\n- Để làm việc với ES6 ngay từ bây giờ, bạn cần transpiler **Javascript-to-Javascript**\n- Transpiler có chức năng\n\n  - Biên dịch code của bạn từ phiên bản mới nhất (của Javascript) về phiên bản cũ hơn\n  - Khi mà trình duyệt đã tương thích với phiên bản mới, chúng ta sẽ biên dịch từ ES2016 và ES2017 về ES6, ... và tiếp tục như vậy.\n  - Hỗ trợ source map\n  - Bạn có thể tự tin viết code ES6 và dùng trong thực tế ngay từ bây giờ (tuy nhiên, trình duyệt sẽ nhận được code ES5)\n\n- Babel (một transpiler) có một tính năng mà không có đối thủ nào cạnh tranh được: xuất ra code mà bạn **có thể đọc được**\n\n  - Dùng `babel` để biên dịch ES6 xuống ES5\n  - Dùng `babelify` kết hợp với `babel` cùng với Gulp, Grunt, hoặc npm run trong khi build.\n  - Dùng Node.js v4.x.x sẽ có native support cho ES6 (:+1: cho V8)\n  - Dùng `babel-node` với bất kì phiên bản node nào, sẽ biên dịch module xuống ES5\n  - Babel có một kho plugins và hệ sinh thái phong phú.\n\n# Destructuring\n\n- `var {foo} = pony` tương đượng với `var foo = pony.foo`\n- `var {foo: baz} = pony` tương đương với `var baz = pony.foo`\n- Bạn có thể cung cấp giá trị mặc định , `var {foo='bar'} = baz` cho ra `foo: 'bar'` nếu `baz.foo === undefined`\n- Bạn có thể lấy bao nhiêu giá trị tùy thích `var {foo, bar: baz} = {foo: 0, bar: 1}` cho ra `foo: 0` và `baz: 1`\n- Bạn có thể lấy giá trị lồng vào nhau. `var {foo: {bar}} = { foo: { bar: 'baz' } }` cho ra  `bar: 'baz'`\n- Bạn cũng có thể đặt tên cho nó. `var {foo: {bar: deep}} = { foo: { bar: 'baz' } }` cho ra `deep: 'baz'`\n- Thuộc tính không tình thấy sẽ cho ra `undefined` như bình thường. Ví dụ `var {foo} = {}`\n- Giá trị lồng vào nhau không tồn tại sẽ cho ra lỗi, ví dụ: `var {foo: {bar}} = {}`\n- Mảng cũng tương tự, `[a, b] = [0, 1]` cho ra `a: 0` và `b: 1`\n- Bạn có thể bỏ qua các giá trị trong mảng, `[a, , b] = [0, 1, 2]`, cho ra `a: 0` và `b: 2`\n- Bạn có thể thay đổi vị trí mà không cần biết trung gian `[a, b] = [b, a]`\n- Bạn cũng có thể destruct các tham số của hàm\n\n  - Gán giá trị mặc định cho hàm `function foo (bar=2) {}`\n  - Giá trị mặc định cũng có thể là object `function foo (bar={ a: 1, b: 2 }) {}`\n  - Chúng ta có thể destruct biến `bar` ở trên hoàn toàn thế này `function foo ({ a=1, b=2 }) {}`\n  - Hoặc có thể đặt giá trị mặt định là một object rỗng nếu như không có bất kì tham số nào `function foo ({ a=1, b=2 } = {}) {}`\n\n# Spread Operator and Rest Parameters\n\n- Rest Parameters (tạm dịch là các tham số còn lại) sẽ `arguments` tốt hơn\n\n  - Bạn có thể định nghĩa nó trong hàm thế này `function foo (...everything) {}`\n  - `everything` là một mảng gồm tất cả tham số được gửi đến hàm `foo`\n  - Bạn có thể đặt tên cho vài tham số trước `...everything` thế này `function foo (bar, ...rest) {}`\n  - Các tham số đã được đặt tên sẽ được loại ra khỏi `...rest`\n  - `...rest` phải là tham số cuối cùng trong danh sách\n- Spread operator giống như là ma thuật, nó cũng có cú pháp `...`\n\n  - Không cần dùng `.apply` khi gọi method, `fn(...[1, 2, 3])` tương đương với `fn(1, 2, 3)`\n  - Dễ gộp mạng hơn `[1, 2, ...[3, 4, 5], 6, 7]`\n  - Chuyển đổi các biến dạng mảng hoặc `iterable` thành mảng, ví dụ: `[...document.querySelectorAll('img')]`\n  - Có thể dùng khi destruct, `[a, , ...rest] = [1, 2, 3, 4, 5]` cho ra `a: 1` và `rest: [3, 4, 5]`\n  - Cần thiết khi dùng `new Date` thế này `new Date(...[2015, 31, 8])`\n\n# Arrow function\n\n- Tạo hàm nhanh chóng thế này `param => returnValue`\n- Hữu ích khi lập trình hàm (funtional programing) `[1, 2].map(x => x * 2)`\n- Có nhiều cách để dùng, có thể làm bạn rối lúc đầu\n\n  - `p1 => expr` khi chỉ có một tham số\n  - `p1 => expr` có nghĩa là hàm sẽ trả về kết quả `expr`\n  - Để trả về một object, đặt nó trong một cặp ngoặc `() => ({ foo: 'bar' })` nếu không sẽ bị lỗi cú pháp\n  - Cặp ngoặc có thể dùng khi bạn có không, một, hai hoặc nhiều tham số hơn `() => expr or (p1, p2) => expr`\n  - Cặp ngoặc bên phải có nghĩa là khối code có thể có nhiều dòng `() => {}`\n  - Khi bạn dùng khối code, sẽ không có `return` tự động, bạn phải thêm vào như mọi khi `() => { return 'foo' }`\n- You can’t name arrow functions statically, but runtimes are now much better at inferring names for most methods.\n- Scope trong arrow function chính là scope của chính arrow function\n\n  - `this` trong arrow function sẽ giống với `this` ở parent scope.\n  - `this` không thể thay đổi bằng `.call`, `.apply`, hoặc là các phương thức tương tự.\n\n> Xem thêm: [http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function]\n\n# Template Literals\n\n- Bạn có thể định nghĩa chuỗi với dấu `` ` `` (backtick), thay vì kiểu cũ là `\"` và `'`\n- Chuỗi mà bao trong dấu backtick gọi là template literals\n- Template literals có thể gồm nhiều dòng\n- Template literals cho phép bạn đặt biến vào thế này `khoanguyen.me is ${rating}` (với `rating` là một biến)\n- Bạn có thể đặt vào bất cứ thứ gì hợp lệ với Javascript trong cặp ngoặc như `${2 * 3}` hoặc `${foo()}`\n- Bạn có thể thay đổi kết quả kết template literals\n\n  - Thêm vào trước `fn` thế này ``fn`foo, ${bar} and ${baz}```\n  - `fn` sẽ được gọi với tham số  `template, ...expressions`\n  - `template` là `['foo, ', ' and ', '']` và `expressions` là `[bar, baz]`\n  - Kết quả trả về của `fn` sẽ trở thành giá trị của template literal.\n- Tổng kết lại thì định nghĩa chuỗi với template literals tốt hơn so với việc dùng cặp nháy đơn hay nháy kép\n\n# Object Literals\n\n- Thay vì phải viết `{ foo: foo }`, bây giờ bạn chỉ cần viết  `{ foo }` – đây được gọi *property value shorthand* (tạm dịch: định nhanh giá trị của thuộc tính)\n- Tính toán tên thuộc tính (*Computed property names*), `{ [prefix + 'Foo']: 'bar' }`, khi `prefix: 'moz'`, sẽ cho ra kết quả `{ mozFoo: 'bar' }`\n- Bạn không thể kết hợp computed property names và property value shorthands, `{ [foo] }` là không hợp lệ\n- Bạn có thể định method cho object literal bằng cú pháp nhanh này: `{ foo () {} }`\n\n# Class\n\n- Không phải là class như OOP, chỉ là một cú pháp gọn hơn dựa trên prototype\n- Cú pháp giống như định object `class Foo {}`\n- Instance methods – `new Foo().bar` – được định nghĩa nhờ cú pháp *object literal* như trên `class Foo { bar () {} }`\n- Static methods – `Foo.isPonyFoo()` – cần thêm `static` vào trước, `class Foo { static isPonyFoo () {} }`\n- Constructor  `class Foo { constructor () { /* initialize instance */ } }`\n- Thừa kế nhờ cấu trúc thế này `class PonyFoo extends Foo {}`\n\n# Let và Const\n\n- `let` và `const` là hai cách khác ngoài `var` để khởi tạo biến.\n- `let` là `block-scoped` thay vì `lexically scoped` như hàm.\n- `let` gắn với `block` hiện tại, trong khi `var` gắn với `block` của hàm\n- “Temporal Dead Zone” (gọi tắt TDZ)\n\n  - Bắt đầu ở `block` mà `let foo` được khởi tạo\n  - Kết thúc khi thực hiện câu lệnh khởi tạo `let foo`\n  - Cố gắng truy cập hoặc gán biến trong vùng TDZ (tức là trước câu lên `let foo`) sẽ gây ra lỗi\n  - Giúp tránh các lỗi đau đầu khi biến bị thay đổi trước khi nó được khởi tạo (có thể hiểu như là `\"use strict\"`)\n- `const` cũng là `block-scoped` gắn và ràng buộc bởi TDZ\n- Khi dùng `const`, biến cần phải gắn giá trị ngay khi khởi tạo `const foo = 'bar'`\n- Gán giá trị cho `const` sau khi khởi tạo sẽ gây lỗi một ách im lặng hay `throw` trong `\"use strict\"`.\n- Giá trị của biến `const` không phải là hằng định (immutable)\n\n  - `const foo = { bar: 'baz' }; foo.bar = 'boo'` sẽ không `throw` lỗi\n- Khởi tạo biến cùng tên sẽ `throw` lỗi\n- Định tạo ra để khắc phục vấn đề ghi đè biến.\n\n# Symbol\n\n- Một kiểu dữ liệu mới của ES6\n- Bạn có thể khởi tạo symbol thế này `var symbol = Symbol()`\n- Bạn có thể thêm chú thích để dễ debug `Symbol('ponyfoo')`\n- Symbol là hằng định và độc nhất. `Symbol(), Symbol(), Symbol('foo') và Symbol('foo')` cả 4 giá trị trên khác nhau hoàn toàn.\n- `typeof Symbol() === 'symbol'`\n- You can also create global symbols with Symbol.for(key)\nIf a symbol with the provided key already existed, you get that one back\nOtherwise, a new symbol is created, using key as its description as well\nSymbol.keyFor(symbol) is the inverse function, taking a symbol and returning its key\nGlobal symbols are as global as it gets, or cross-realm. Single registry used to look up these symbols across the runtime\n`window context`\n`eval context`\n`<iframe> context, Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')`\nThere’s also “well-known” symbols\nNot on the global registry, accessible through Symbol[name], e.g: Symbol.iterator\nCross-realm, meaning Symbol.iterator === iframe.contentWindow.Symbol.iterator\nUsed by specification to define protocols, such as the iterable protocol over Symbol.iterator\nThey’re not actually well-known – in colloquial terms\nIterating over symbol properties is hard, but not impossible and definitely not private\nSymbols are hidden to all pre-ES6 “reflection” methods\nSymbols are accessible through Object.getOwnPropertySymbols\nYou won’t stumble upon them but you will find them if actively looking\n","__filename":"es6.md","__url":"/es6/","__resourceUrl":"/es6/index.html","__dataUrl":"/es6/index.html.dec750c93567f29d43f8c0049af36cf4.json","type":"Post"}}}</script><script src="/w-2-client.a955f9a95b0e5ca5ca5e.js"></script></body></html>
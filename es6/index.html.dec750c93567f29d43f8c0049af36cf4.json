{"head":{"layout":"Post","title":"Tổng quan ES6 qua 350 điểm","date":"2016-02-21T20:20:00.000Z","tags":["js"],"draft":true,"translate":{"url":"https://ponyfoo.com/articles/es6","author":"Pony Foo"},"description":"Giới thiệu ES6, còn được biết với tên Harmony, es-next, ES2015 là bản mô tả mới nhất của Javascript Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015) Các bản mô tả tiếp theo…"},"body":"<h1 id=\"Gioi-thieu\"><a class=\"markdownIt-Anchor\" href=\"#Gioi-thieu\">#</a> Giới thiệu</h1>\n<ul>\n<li>\n<p>ES6, còn được biết với tên Harmony, <code>es-next</code>, ES2015 là bản mô tả mới nhất của Javascript</p>\n</li>\n<li>\n<p>Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)</p>\n</li>\n<li>\n<p>Các bản mô tả tiếp theo của Javascript sẽ được đặt tên theo dạng ES[YYYY], ví dụ ES2016 cho ES7</p>\n<ul>\n<li>Sẽ cập nhật mỗi năm, tính năng nào không hoàn thành sẽ bị hoãn lại tới năm tiếp theo</li>\n<li>Vì ES6 được bắt đầu trước khi cách gọi mới này ra đời nên chúng ta vẫn thường gọi là ES6</li>\n<li>Bắt đầu từ ES2016 (ES7), chúng ta nên bắt đầu dùng dạng ES[YYYY] để gọi tên phiên bản Javascript.</li>\n<li>Lý do quan trọng nhất khi đặt tên như vậy là để gây áp lực, và buộc các trình duyệt phải thêm tính năng mới vào nhanh hơn.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Cong-cu\"><a class=\"markdownIt-Anchor\" href=\"#Cong-cu\">#</a> Công cụ</h1>\n<ul>\n<li>\n<p>Để làm việc với ES6 ngay từ bây giờ, bạn cần transpiler <strong>Javascript-to-Javascript</strong></p>\n</li>\n<li>\n<p>Transpiler có chức năng</p>\n<ul>\n<li>Biên dịch code của bạn từ phiên bản mới nhất (của Javascript) về phiên bản cũ hơn</li>\n<li>Khi mà trình duyệt đã tương thích với phiên bản mới, chúng ta sẽ biên dịch từ ES2016 và ES2017 về ES6, … và tiếp tục như vậy.</li>\n<li>Hỗ trợ source map</li>\n<li>Bạn có thể tự tin viết code ES6 và dùng trong thực tế ngay từ bây giờ (tuy nhiên, trình duyệt sẽ nhận được code ES5)</li>\n</ul>\n</li>\n<li>\n<p>Babel (một transpiler) có một tính năng mà không có đối thủ nào cạnh tranh được: xuất ra code mà bạn <strong>có thể đọc được</strong></p>\n<ul>\n<li>Dùng <code>babel</code> để biên dịch ES6 xuống ES5</li>\n<li>Dùng <code>babelify</code> kết hợp với <code>babel</code> cùng với Gulp, Grunt, hoặc npm run trong khi build.</li>\n<li>Dùng Node.js v4.x.x sẽ có native support cho ES6 (:+1: cho V8)</li>\n<li>Dùng <code>babel-node</code> với bất kì phiên bản node nào, sẽ biên dịch module xuống ES5</li>\n<li>Babel có một kho plugins và hệ sinh thái phong phú.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Destructuring\"><a class=\"markdownIt-Anchor\" href=\"#Destructuring\">#</a> Destructuring</h1>\n<ul>\n<li>\n<p><code>var {foo} = pony</code> tương đượng với <code>var foo = pony.foo</code></p>\n</li>\n<li>\n<p><code>var {foo: baz} = pony</code> tương đương với <code>var baz = pony.foo</code></p>\n</li>\n<li>\n<p>Bạn có thể cung cấp giá trị mặc định , <code>var {foo='bar'} = baz</code> cho ra <code>foo: 'bar'</code> nếu <code>baz.foo === undefined</code></p>\n</li>\n<li>\n<p>Bạn có thể lấy bao nhiêu giá trị tùy thích <code>var {foo, bar: baz} = {foo: 0, bar: 1}</code> cho ra <code>foo: 0</code> và <code>baz: 1</code></p>\n</li>\n<li>\n<p>Bạn có thể lấy giá trị lồng vào nhau. <code>var {foo: {bar}} = { foo: { bar: 'baz' } }</code> cho ra  <code>bar: 'baz'</code></p>\n</li>\n<li>\n<p>Bạn cũng có thể đặt tên cho nó. <code>var {foo: {bar: deep}} = { foo: { bar: 'baz' } }</code> cho ra <code>deep: 'baz'</code></p>\n</li>\n<li>\n<p>Thuộc tính không tình thấy sẽ cho ra <code>undefined</code> như bình thường. Ví dụ <code>var {foo} = {}</code></p>\n</li>\n<li>\n<p>Giá trị lồng vào nhau không tồn tại sẽ cho ra lỗi, ví dụ: <code>var {foo: {bar}} = {}</code></p>\n</li>\n<li>\n<p>Mảng cũng tương tự, <code>[a, b] = [0, 1]</code> cho ra <code>a: 0</code> và <code>b: 1</code></p>\n</li>\n<li>\n<p>Bạn có thể bỏ qua các giá trị trong mảng, <code>[a, , b] = [0, 1, 2]</code>, cho ra <code>a: 0</code> và <code>b: 2</code></p>\n</li>\n<li>\n<p>Bạn có thể thay đổi vị trí mà không cần biết trung gian <code>[a, b] = [b, a]</code></p>\n</li>\n<li>\n<p>Bạn cũng có thể destruct các tham số của hàm</p>\n<ul>\n<li>Gán giá trị mặc định cho hàm <code>function foo (bar=2) {}</code></li>\n<li>Giá trị mặc định cũng có thể là object <code>function foo (bar={ a: 1, b: 2 }) {}</code></li>\n<li>Chúng ta có thể destruct biến <code>bar</code> ở trên hoàn toàn thế này <code>function foo ({ a=1, b=2 }) {}</code></li>\n<li>Hoặc có thể đặt giá trị mặt định là một object rỗng nếu như không có bất kì tham số nào <code>function foo ({ a=1, b=2 } = {}) {}</code></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Spread-Operator-and-Rest-Parameters\"><a class=\"markdownIt-Anchor\" href=\"#Spread-Operator-and-Rest-Parameters\">#</a> Spread Operator and Rest Parameters</h1>\n<ul>\n<li>\n<p>Rest Parameters (tạm dịch là các tham số còn lại) sẽ <code>arguments</code> tốt hơn</p>\n<ul>\n<li>Bạn có thể định nghĩa nó trong hàm thế này <code>function foo (...everything) {}</code></li>\n<li><code>everything</code> là một mảng gồm tất cả tham số được gửi đến hàm <code>foo</code></li>\n<li>Bạn có thể đặt tên cho vài tham số trước <code>...everything</code> thế này <code>function foo (bar, ...rest) {}</code></li>\n<li>Các tham số đã được đặt tên sẽ được loại ra khỏi <code>...rest</code></li>\n<li><code>...rest</code> phải là tham số cuối cùng trong danh sách</li>\n</ul>\n</li>\n<li>\n<p>Spread operator giống như là ma thuật, nó cũng có cú pháp <code>...</code></p>\n<ul>\n<li>Không cần dùng <code>.apply</code> khi gọi method, <code>fn(...[1, 2, 3])</code> tương đương với <code>fn(1, 2, 3)</code></li>\n<li>Dễ gộp mạng hơn <code>[1, 2, ...[3, 4, 5], 6, 7]</code></li>\n<li>Chuyển đổi các biến dạng mảng hoặc <code>iterable</code> thành mảng, ví dụ: <code>[...document.querySelectorAll('img')]</code></li>\n<li>Có thể dùng khi destruct, <code>[a, , ...rest] = [1, 2, 3, 4, 5]</code> cho ra <code>a: 1</code> và <code>rest: [3, 4, 5]</code></li>\n<li>Cần thiết khi dùng <code>new Date</code> thế này <code>new Date(...[2015, 31, 8])</code></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Arrow-function\"><a class=\"markdownIt-Anchor\" href=\"#Arrow-function\">#</a> Arrow function</h1>\n<ul>\n<li>\n<p>Tạo hàm nhanh chóng thế này <code>param =&gt; returnValue</code></p>\n</li>\n<li>\n<p>Hữu ích khi lập trình hàm (funtional programing) <code>[1, 2].map(x =&gt; x * 2)</code></p>\n</li>\n<li>\n<p>Có nhiều cách để dùng, có thể làm bạn rối lúc đầu</p>\n<ul>\n<li><code>p1 =&gt; expr</code> khi chỉ có một tham số</li>\n<li><code>p1 =&gt; expr</code> có nghĩa là hàm sẽ trả về kết quả <code>expr</code></li>\n<li>Để trả về một object, đặt nó trong một cặp ngoặc <code>() =&gt; ({ foo: 'bar' })</code> nếu không sẽ bị lỗi cú pháp</li>\n<li>Cặp ngoặc có thể dùng khi bạn có không, một, hai hoặc nhiều tham số hơn <code>() =&gt; expr or (p1, p2) =&gt; expr</code></li>\n<li>Cặp ngoặc bên phải có nghĩa là khối code có thể có nhiều dòng <code>() =&gt; {}</code></li>\n<li>Khi bạn dùng khối code, sẽ không có <code>return</code> tự động, bạn phải thêm vào như mọi khi <code>() =&gt; { return 'foo' }</code></li>\n</ul>\n</li>\n<li>\n<p>You can’t name arrow functions statically, but runtimes are now much better at inferring names for most methods.</p>\n</li>\n<li>\n<p>Scope trong arrow function chính là scope của chính arrow function</p>\n<ul>\n<li><code>this</code> trong arrow function sẽ giống với <code>this</code> ở parent scope.</li>\n<li><code>this</code> không thể thay đổi bằng <code>.call</code>, <code>.apply</code>, hoặc là các phương thức tương tự.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Xem thêm: [<a href=\"http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function\">http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function</a>]</p>\n</blockquote>\n<h1 id=\"Template-Literals\"><a class=\"markdownIt-Anchor\" href=\"#Template-Literals\">#</a> Template Literals</h1>\n<ul>\n<li>\n<p>Bạn có thể định nghĩa chuỗi với dấu <code>`</code> (backtick), thay vì kiểu cũ là <code>&quot;</code> và <code>'</code></p>\n</li>\n<li>\n<p>Chuỗi mà bao trong dấu backtick gọi là template literals</p>\n</li>\n<li>\n<p>Template literals có thể gồm nhiều dòng</p>\n</li>\n<li>\n<p>Template literals cho phép bạn đặt biến vào thế này <code>khoanguyen.me is ${rating}</code> (với <code>rating</code> là một biến)</p>\n</li>\n<li>\n<p>Bạn có thể đặt vào bất cứ thứ gì hợp lệ với Javascript trong cặp ngoặc như <code>${2 * 3}</code> hoặc <code>${foo()}</code></p>\n</li>\n<li>\n<p>Bạn có thể thay đổi kết quả kết template literals</p>\n<ul>\n<li>Thêm vào trước <code>fn</code> thế này ``fn`foo, ${bar} and ${baz}```</li>\n<li><code>fn</code> sẽ được gọi với tham số  <code>template, ...expressions</code></li>\n<li><code>template</code> là <code>['foo, ', ' and ', '']</code> và <code>expressions</code> là <code>[bar, baz]</code></li>\n<li>Kết quả trả về của <code>fn</code> sẽ trở thành giá trị của template literal.</li>\n</ul>\n</li>\n<li>\n<p>Tổng kết lại thì định nghĩa chuỗi với template literals tốt hơn so với việc dùng cặp nháy đơn hay nháy kép</p>\n</li>\n</ul>\n<h1 id=\"Object-Literals\"><a class=\"markdownIt-Anchor\" href=\"#Object-Literals\">#</a> Object Literals</h1>\n<ul>\n<li>Thay vì phải viết <code>{ foo: foo }</code>, bây giờ bạn chỉ cần viết  <code>{ foo }</code> – đây được gọi <em>property value shorthand</em> (tạm dịch: định nhanh giá trị của thuộc tính)</li>\n<li>Tính toán tên thuộc tính (<em>Computed property names</em>), <code>{ [prefix + 'Foo']: 'bar' }</code>, khi <code>prefix: 'moz'</code>, sẽ cho ra kết quả <code>{ mozFoo: 'bar' }</code></li>\n<li>Bạn không thể kết hợp computed property names và property value shorthands, <code>{ [foo] }</code> là không hợp lệ</li>\n<li>Bạn có thể định method cho object literal bằng cú pháp nhanh này: <code>{ foo () {} }</code></li>\n</ul>\n<h1 id=\"Class\"><a class=\"markdownIt-Anchor\" href=\"#Class\">#</a> Class</h1>\n<ul>\n<li>Không phải là class như OOP, chỉ là một cú pháp gọn hơn dựa trên prototype</li>\n<li>Cú pháp giống như định object <code>class Foo {}</code></li>\n<li>Instance methods – <code>new Foo().bar</code> – được định nghĩa nhờ cú pháp <em>object literal</em> như trên <code>class Foo { bar () {} }</code></li>\n<li>Static methods – <code>Foo.isPonyFoo()</code> – cần thêm <code>static</code> vào trước, <code>class Foo { static isPonyFoo () {} }</code></li>\n<li>Constructor  <code>class Foo { constructor () { /* initialize instance */ } }</code></li>\n<li>Thừa kế nhờ cấu trúc thế này <code>class PonyFoo extends Foo {}</code></li>\n</ul>\n<h1 id=\"Let-va-Const\"><a class=\"markdownIt-Anchor\" href=\"#Let-va-Const\">#</a> Let và Const</h1>\n<ul>\n<li>\n<p><code>let</code> và <code>const</code> là hai cách khác ngoài <code>var</code> để khởi tạo biến.</p>\n</li>\n<li>\n<p><code>let</code> là <code>block-scoped</code> thay vì <code>lexically scoped</code> như hàm.</p>\n</li>\n<li>\n<p><code>let</code> gắn với <code>block</code> hiện tại, trong khi <code>var</code> gắn với <code>block</code> của hàm</p>\n</li>\n<li>\n<p>“Temporal Dead Zone” (gọi tắt TDZ)</p>\n<ul>\n<li>Bắt đầu ở <code>block</code> mà <code>let foo</code> được khởi tạo</li>\n<li>Kết thúc khi thực hiện câu lệnh khởi tạo <code>let foo</code></li>\n<li>Cố gắng truy cập hoặc gán biến trong vùng TDZ (tức là trước câu lên <code>let foo</code>) sẽ gây ra lỗi</li>\n<li>Giúp tránh các lỗi đau đầu khi biến bị thay đổi trước khi nó được khởi tạo (có thể hiểu như là <code>&quot;use strict&quot;</code>)</li>\n</ul>\n</li>\n<li>\n<p><code>const</code> cũng là <code>block-scoped</code> gắn và ràng buộc bởi TDZ</p>\n</li>\n<li>\n<p>Khi dùng <code>const</code>, biến cần phải gắn giá trị ngay khi khởi tạo <code>const foo = 'bar'</code></p>\n</li>\n<li>\n<p>Gán giá trị cho <code>const</code> sau khi khởi tạo sẽ gây lỗi một ách im lặng hay <code>throw</code> trong <code>&quot;use strict&quot;</code>.</p>\n</li>\n<li>\n<p>Giá trị của biến <code>const</code> không phải là hằng định (immutable)</p>\n<ul>\n<li><code>const foo = { bar: 'baz' }; foo.bar = 'boo'</code> sẽ không <code>throw</code> lỗi</li>\n</ul>\n</li>\n<li>\n<p>Khởi tạo biến cùng tên sẽ <code>throw</code> lỗi</p>\n</li>\n<li>\n<p>Định tạo ra để khắc phục vấn đề ghi đè biến.</p>\n</li>\n</ul>\n<h1 id=\"Symbol\"><a class=\"markdownIt-Anchor\" href=\"#Symbol\">#</a> Symbol</h1>\n<ul>\n<li>Một kiểu dữ liệu mới của ES6</li>\n<li>Bạn có thể khởi tạo symbol thế này <code>var symbol = Symbol()</code></li>\n<li>Bạn có thể thêm chú thích để dễ debug <code>Symbol('ponyfoo')</code></li>\n<li>Symbol là hằng định và độc nhất. <code>Symbol(), Symbol(), Symbol('foo') và Symbol('foo')</code> cả 4 giá trị trên khác nhau hoàn toàn.</li>\n<li><code>typeof Symbol() === 'symbol'</code></li>\n<li>You can also create global symbols with Symbol.for(key)\nIf a symbol with the provided key already existed, you get that one back\nOtherwise, a new symbol is created, using key as its description as well\nSymbol.keyFor(symbol) is the inverse function, taking a symbol and returning its key\nGlobal symbols are as global as it gets, or cross-realm. Single registry used to look up these symbols across the runtime\n<code>window context</code>\n<code>eval context</code>\n<code>&lt;iframe&gt; context, Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')</code>\nThere’s also “well-known” symbols\nNot on the global registry, accessible through Symbol[name], e.g: Symbol.iterator\nCross-realm, meaning Symbol.iterator === iframe.contentWindow.Symbol.iterator\nUsed by specification to define protocols, such as the iterable protocol over Symbol.iterator\nThey’re not actually well-known – in colloquial terms\nIterating over symbol properties is hard, but not impossible and definitely not private\nSymbols are hidden to all pre-ES6 “reflection” methods\nSymbols are accessible through Object.getOwnPropertySymbols\nYou won’t stumble upon them but you will find them if actively looking</li>\n</ul>\n","rawBody":"\n# Giới thiệu\n\n- ES6, còn được biết với tên Harmony, `es-next`, ES2015 là bản mô tả mới nhất của Javascript\n- Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)\n- Các bản mô tả tiếp theo của Javascript sẽ được đặt tên theo dạng ES[YYYY], ví dụ ES2016 cho ES7\n\n  - Sẽ cập nhật mỗi năm, tính năng nào không hoàn thành sẽ bị hoãn lại tới năm tiếp theo\n  - Vì ES6 được bắt đầu trước khi cách gọi mới này ra đời nên chúng ta vẫn thường gọi là ES6\n  - Bắt đầu từ ES2016 (ES7), chúng ta nên bắt đầu dùng dạng ES[YYYY] để gọi tên phiên bản Javascript.\n  - Lý do quan trọng nhất khi đặt tên như vậy là để gây áp lực, và buộc các trình duyệt phải thêm tính năng mới vào nhanh hơn.\n\n# Công cụ\n\n- Để làm việc với ES6 ngay từ bây giờ, bạn cần transpiler **Javascript-to-Javascript**\n- Transpiler có chức năng\n\n  - Biên dịch code của bạn từ phiên bản mới nhất (của Javascript) về phiên bản cũ hơn\n  - Khi mà trình duyệt đã tương thích với phiên bản mới, chúng ta sẽ biên dịch từ ES2016 và ES2017 về ES6, ... và tiếp tục như vậy.\n  - Hỗ trợ source map\n  - Bạn có thể tự tin viết code ES6 và dùng trong thực tế ngay từ bây giờ (tuy nhiên, trình duyệt sẽ nhận được code ES5)\n\n- Babel (một transpiler) có một tính năng mà không có đối thủ nào cạnh tranh được: xuất ra code mà bạn **có thể đọc được**\n\n  - Dùng `babel` để biên dịch ES6 xuống ES5\n  - Dùng `babelify` kết hợp với `babel` cùng với Gulp, Grunt, hoặc npm run trong khi build.\n  - Dùng Node.js v4.x.x sẽ có native support cho ES6 (:+1: cho V8)\n  - Dùng `babel-node` với bất kì phiên bản node nào, sẽ biên dịch module xuống ES5\n  - Babel có một kho plugins và hệ sinh thái phong phú.\n\n# Destructuring\n\n- `var {foo} = pony` tương đượng với `var foo = pony.foo`\n- `var {foo: baz} = pony` tương đương với `var baz = pony.foo`\n- Bạn có thể cung cấp giá trị mặc định , `var {foo='bar'} = baz` cho ra `foo: 'bar'` nếu `baz.foo === undefined`\n- Bạn có thể lấy bao nhiêu giá trị tùy thích `var {foo, bar: baz} = {foo: 0, bar: 1}` cho ra `foo: 0` và `baz: 1`\n- Bạn có thể lấy giá trị lồng vào nhau. `var {foo: {bar}} = { foo: { bar: 'baz' } }` cho ra  `bar: 'baz'`\n- Bạn cũng có thể đặt tên cho nó. `var {foo: {bar: deep}} = { foo: { bar: 'baz' } }` cho ra `deep: 'baz'`\n- Thuộc tính không tình thấy sẽ cho ra `undefined` như bình thường. Ví dụ `var {foo} = {}`\n- Giá trị lồng vào nhau không tồn tại sẽ cho ra lỗi, ví dụ: `var {foo: {bar}} = {}`\n- Mảng cũng tương tự, `[a, b] = [0, 1]` cho ra `a: 0` và `b: 1`\n- Bạn có thể bỏ qua các giá trị trong mảng, `[a, , b] = [0, 1, 2]`, cho ra `a: 0` và `b: 2`\n- Bạn có thể thay đổi vị trí mà không cần biết trung gian `[a, b] = [b, a]`\n- Bạn cũng có thể destruct các tham số của hàm\n\n  - Gán giá trị mặc định cho hàm `function foo (bar=2) {}`\n  - Giá trị mặc định cũng có thể là object `function foo (bar={ a: 1, b: 2 }) {}`\n  - Chúng ta có thể destruct biến `bar` ở trên hoàn toàn thế này `function foo ({ a=1, b=2 }) {}`\n  - Hoặc có thể đặt giá trị mặt định là một object rỗng nếu như không có bất kì tham số nào `function foo ({ a=1, b=2 } = {}) {}`\n\n# Spread Operator and Rest Parameters\n\n- Rest Parameters (tạm dịch là các tham số còn lại) sẽ `arguments` tốt hơn\n\n  - Bạn có thể định nghĩa nó trong hàm thế này `function foo (...everything) {}`\n  - `everything` là một mảng gồm tất cả tham số được gửi đến hàm `foo`\n  - Bạn có thể đặt tên cho vài tham số trước `...everything` thế này `function foo (bar, ...rest) {}`\n  - Các tham số đã được đặt tên sẽ được loại ra khỏi `...rest`\n  - `...rest` phải là tham số cuối cùng trong danh sách\n- Spread operator giống như là ma thuật, nó cũng có cú pháp `...`\n\n  - Không cần dùng `.apply` khi gọi method, `fn(...[1, 2, 3])` tương đương với `fn(1, 2, 3)`\n  - Dễ gộp mạng hơn `[1, 2, ...[3, 4, 5], 6, 7]`\n  - Chuyển đổi các biến dạng mảng hoặc `iterable` thành mảng, ví dụ: `[...document.querySelectorAll('img')]`\n  - Có thể dùng khi destruct, `[a, , ...rest] = [1, 2, 3, 4, 5]` cho ra `a: 1` và `rest: [3, 4, 5]`\n  - Cần thiết khi dùng `new Date` thế này `new Date(...[2015, 31, 8])`\n\n# Arrow function\n\n- Tạo hàm nhanh chóng thế này `param => returnValue`\n- Hữu ích khi lập trình hàm (funtional programing) `[1, 2].map(x => x * 2)`\n- Có nhiều cách để dùng, có thể làm bạn rối lúc đầu\n\n  - `p1 => expr` khi chỉ có một tham số\n  - `p1 => expr` có nghĩa là hàm sẽ trả về kết quả `expr`\n  - Để trả về một object, đặt nó trong một cặp ngoặc `() => ({ foo: 'bar' })` nếu không sẽ bị lỗi cú pháp\n  - Cặp ngoặc có thể dùng khi bạn có không, một, hai hoặc nhiều tham số hơn `() => expr or (p1, p2) => expr`\n  - Cặp ngoặc bên phải có nghĩa là khối code có thể có nhiều dòng `() => {}`\n  - Khi bạn dùng khối code, sẽ không có `return` tự động, bạn phải thêm vào như mọi khi `() => { return 'foo' }`\n- You can’t name arrow functions statically, but runtimes are now much better at inferring names for most methods.\n- Scope trong arrow function chính là scope của chính arrow function\n\n  - `this` trong arrow function sẽ giống với `this` ở parent scope.\n  - `this` không thể thay đổi bằng `.call`, `.apply`, hoặc là các phương thức tương tự.\n\n> Xem thêm: [http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function]\n\n# Template Literals\n\n- Bạn có thể định nghĩa chuỗi với dấu `` ` `` (backtick), thay vì kiểu cũ là `\"` và `'`\n- Chuỗi mà bao trong dấu backtick gọi là template literals\n- Template literals có thể gồm nhiều dòng\n- Template literals cho phép bạn đặt biến vào thế này `khoanguyen.me is ${rating}` (với `rating` là một biến)\n- Bạn có thể đặt vào bất cứ thứ gì hợp lệ với Javascript trong cặp ngoặc như `${2 * 3}` hoặc `${foo()}`\n- Bạn có thể thay đổi kết quả kết template literals\n\n  - Thêm vào trước `fn` thế này ``fn`foo, ${bar} and ${baz}```\n  - `fn` sẽ được gọi với tham số  `template, ...expressions`\n  - `template` là `['foo, ', ' and ', '']` và `expressions` là `[bar, baz]`\n  - Kết quả trả về của `fn` sẽ trở thành giá trị của template literal.\n- Tổng kết lại thì định nghĩa chuỗi với template literals tốt hơn so với việc dùng cặp nháy đơn hay nháy kép\n\n# Object Literals\n\n- Thay vì phải viết `{ foo: foo }`, bây giờ bạn chỉ cần viết  `{ foo }` – đây được gọi *property value shorthand* (tạm dịch: định nhanh giá trị của thuộc tính)\n- Tính toán tên thuộc tính (*Computed property names*), `{ [prefix + 'Foo']: 'bar' }`, khi `prefix: 'moz'`, sẽ cho ra kết quả `{ mozFoo: 'bar' }`\n- Bạn không thể kết hợp computed property names và property value shorthands, `{ [foo] }` là không hợp lệ\n- Bạn có thể định method cho object literal bằng cú pháp nhanh này: `{ foo () {} }`\n\n# Class\n\n- Không phải là class như OOP, chỉ là một cú pháp gọn hơn dựa trên prototype\n- Cú pháp giống như định object `class Foo {}`\n- Instance methods – `new Foo().bar` – được định nghĩa nhờ cú pháp *object literal* như trên `class Foo { bar () {} }`\n- Static methods – `Foo.isPonyFoo()` – cần thêm `static` vào trước, `class Foo { static isPonyFoo () {} }`\n- Constructor  `class Foo { constructor () { /* initialize instance */ } }`\n- Thừa kế nhờ cấu trúc thế này `class PonyFoo extends Foo {}`\n\n# Let và Const\n\n- `let` và `const` là hai cách khác ngoài `var` để khởi tạo biến.\n- `let` là `block-scoped` thay vì `lexically scoped` như hàm.\n- `let` gắn với `block` hiện tại, trong khi `var` gắn với `block` của hàm\n- “Temporal Dead Zone” (gọi tắt TDZ)\n\n  - Bắt đầu ở `block` mà `let foo` được khởi tạo\n  - Kết thúc khi thực hiện câu lệnh khởi tạo `let foo`\n  - Cố gắng truy cập hoặc gán biến trong vùng TDZ (tức là trước câu lên `let foo`) sẽ gây ra lỗi\n  - Giúp tránh các lỗi đau đầu khi biến bị thay đổi trước khi nó được khởi tạo (có thể hiểu như là `\"use strict\"`)\n- `const` cũng là `block-scoped` gắn và ràng buộc bởi TDZ\n- Khi dùng `const`, biến cần phải gắn giá trị ngay khi khởi tạo `const foo = 'bar'`\n- Gán giá trị cho `const` sau khi khởi tạo sẽ gây lỗi một ách im lặng hay `throw` trong `\"use strict\"`.\n- Giá trị của biến `const` không phải là hằng định (immutable)\n\n  - `const foo = { bar: 'baz' }; foo.bar = 'boo'` sẽ không `throw` lỗi\n- Khởi tạo biến cùng tên sẽ `throw` lỗi\n- Định tạo ra để khắc phục vấn đề ghi đè biến.\n\n# Symbol\n\n- Một kiểu dữ liệu mới của ES6\n- Bạn có thể khởi tạo symbol thế này `var symbol = Symbol()`\n- Bạn có thể thêm chú thích để dễ debug `Symbol('ponyfoo')`\n- Symbol là hằng định và độc nhất. `Symbol(), Symbol(), Symbol('foo') và Symbol('foo')` cả 4 giá trị trên khác nhau hoàn toàn.\n- `typeof Symbol() === 'symbol'`\n- You can also create global symbols with Symbol.for(key)\nIf a symbol with the provided key already existed, you get that one back\nOtherwise, a new symbol is created, using key as its description as well\nSymbol.keyFor(symbol) is the inverse function, taking a symbol and returning its key\nGlobal symbols are as global as it gets, or cross-realm. Single registry used to look up these symbols across the runtime\n`window context`\n`eval context`\n`<iframe> context, Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')`\nThere’s also “well-known” symbols\nNot on the global registry, accessible through Symbol[name], e.g: Symbol.iterator\nCross-realm, meaning Symbol.iterator === iframe.contentWindow.Symbol.iterator\nUsed by specification to define protocols, such as the iterable protocol over Symbol.iterator\nThey’re not actually well-known – in colloquial terms\nIterating over symbol properties is hard, but not impossible and definitely not private\nSymbols are hidden to all pre-ES6 “reflection” methods\nSymbols are accessible through Object.getOwnPropertySymbols\nYou won’t stumble upon them but you will find them if actively looking\n","raw":"---\nlayout: Post\ntitle: \"Tổng quan ES6 qua 350 điểm\"\ndate: 2016-02-21 20:20:00\ntags: [js]\ndraft: true\ntranslate:\n  url: \"https://ponyfoo.com/articles/es6\"\n  author: \"Pony Foo\"\n---\n\n# Giới thiệu\n\n- ES6, còn được biết với tên Harmony, `es-next`, ES2015 là bản mô tả mới nhất của Javascript\n- Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015)\n- Các bản mô tả tiếp theo của Javascript sẽ được đặt tên theo dạng ES[YYYY], ví dụ ES2016 cho ES7\n\n  - Sẽ cập nhật mỗi năm, tính năng nào không hoàn thành sẽ bị hoãn lại tới năm tiếp theo\n  - Vì ES6 được bắt đầu trước khi cách gọi mới này ra đời nên chúng ta vẫn thường gọi là ES6\n  - Bắt đầu từ ES2016 (ES7), chúng ta nên bắt đầu dùng dạng ES[YYYY] để gọi tên phiên bản Javascript.\n  - Lý do quan trọng nhất khi đặt tên như vậy là để gây áp lực, và buộc các trình duyệt phải thêm tính năng mới vào nhanh hơn.\n\n# Công cụ\n\n- Để làm việc với ES6 ngay từ bây giờ, bạn cần transpiler **Javascript-to-Javascript**\n- Transpiler có chức năng\n\n  - Biên dịch code của bạn từ phiên bản mới nhất (của Javascript) về phiên bản cũ hơn\n  - Khi mà trình duyệt đã tương thích với phiên bản mới, chúng ta sẽ biên dịch từ ES2016 và ES2017 về ES6, ... và tiếp tục như vậy.\n  - Hỗ trợ source map\n  - Bạn có thể tự tin viết code ES6 và dùng trong thực tế ngay từ bây giờ (tuy nhiên, trình duyệt sẽ nhận được code ES5)\n\n- Babel (một transpiler) có một tính năng mà không có đối thủ nào cạnh tranh được: xuất ra code mà bạn **có thể đọc được**\n\n  - Dùng `babel` để biên dịch ES6 xuống ES5\n  - Dùng `babelify` kết hợp với `babel` cùng với Gulp, Grunt, hoặc npm run trong khi build.\n  - Dùng Node.js v4.x.x sẽ có native support cho ES6 (:+1: cho V8)\n  - Dùng `babel-node` với bất kì phiên bản node nào, sẽ biên dịch module xuống ES5\n  - Babel có một kho plugins và hệ sinh thái phong phú.\n\n# Destructuring\n\n- `var {foo} = pony` tương đượng với `var foo = pony.foo`\n- `var {foo: baz} = pony` tương đương với `var baz = pony.foo`\n- Bạn có thể cung cấp giá trị mặc định , `var {foo='bar'} = baz` cho ra `foo: 'bar'` nếu `baz.foo === undefined`\n- Bạn có thể lấy bao nhiêu giá trị tùy thích `var {foo, bar: baz} = {foo: 0, bar: 1}` cho ra `foo: 0` và `baz: 1`\n- Bạn có thể lấy giá trị lồng vào nhau. `var {foo: {bar}} = { foo: { bar: 'baz' } }` cho ra  `bar: 'baz'`\n- Bạn cũng có thể đặt tên cho nó. `var {foo: {bar: deep}} = { foo: { bar: 'baz' } }` cho ra `deep: 'baz'`\n- Thuộc tính không tình thấy sẽ cho ra `undefined` như bình thường. Ví dụ `var {foo} = {}`\n- Giá trị lồng vào nhau không tồn tại sẽ cho ra lỗi, ví dụ: `var {foo: {bar}} = {}`\n- Mảng cũng tương tự, `[a, b] = [0, 1]` cho ra `a: 0` và `b: 1`\n- Bạn có thể bỏ qua các giá trị trong mảng, `[a, , b] = [0, 1, 2]`, cho ra `a: 0` và `b: 2`\n- Bạn có thể thay đổi vị trí mà không cần biết trung gian `[a, b] = [b, a]`\n- Bạn cũng có thể destruct các tham số của hàm\n\n  - Gán giá trị mặc định cho hàm `function foo (bar=2) {}`\n  - Giá trị mặc định cũng có thể là object `function foo (bar={ a: 1, b: 2 }) {}`\n  - Chúng ta có thể destruct biến `bar` ở trên hoàn toàn thế này `function foo ({ a=1, b=2 }) {}`\n  - Hoặc có thể đặt giá trị mặt định là một object rỗng nếu như không có bất kì tham số nào `function foo ({ a=1, b=2 } = {}) {}`\n\n# Spread Operator and Rest Parameters\n\n- Rest Parameters (tạm dịch là các tham số còn lại) sẽ `arguments` tốt hơn\n\n  - Bạn có thể định nghĩa nó trong hàm thế này `function foo (...everything) {}`\n  - `everything` là một mảng gồm tất cả tham số được gửi đến hàm `foo`\n  - Bạn có thể đặt tên cho vài tham số trước `...everything` thế này `function foo (bar, ...rest) {}`\n  - Các tham số đã được đặt tên sẽ được loại ra khỏi `...rest`\n  - `...rest` phải là tham số cuối cùng trong danh sách\n- Spread operator giống như là ma thuật, nó cũng có cú pháp `...`\n\n  - Không cần dùng `.apply` khi gọi method, `fn(...[1, 2, 3])` tương đương với `fn(1, 2, 3)`\n  - Dễ gộp mạng hơn `[1, 2, ...[3, 4, 5], 6, 7]`\n  - Chuyển đổi các biến dạng mảng hoặc `iterable` thành mảng, ví dụ: `[...document.querySelectorAll('img')]`\n  - Có thể dùng khi destruct, `[a, , ...rest] = [1, 2, 3, 4, 5]` cho ra `a: 1` và `rest: [3, 4, 5]`\n  - Cần thiết khi dùng `new Date` thế này `new Date(...[2015, 31, 8])`\n\n# Arrow function\n\n- Tạo hàm nhanh chóng thế này `param => returnValue`\n- Hữu ích khi lập trình hàm (funtional programing) `[1, 2].map(x => x * 2)`\n- Có nhiều cách để dùng, có thể làm bạn rối lúc đầu\n\n  - `p1 => expr` khi chỉ có một tham số\n  - `p1 => expr` có nghĩa là hàm sẽ trả về kết quả `expr`\n  - Để trả về một object, đặt nó trong một cặp ngoặc `() => ({ foo: 'bar' })` nếu không sẽ bị lỗi cú pháp\n  - Cặp ngoặc có thể dùng khi bạn có không, một, hai hoặc nhiều tham số hơn `() => expr or (p1, p2) => expr`\n  - Cặp ngoặc bên phải có nghĩa là khối code có thể có nhiều dòng `() => {}`\n  - Khi bạn dùng khối code, sẽ không có `return` tự động, bạn phải thêm vào như mọi khi `() => { return 'foo' }`\n- You can’t name arrow functions statically, but runtimes are now much better at inferring names for most methods.\n- Scope trong arrow function chính là scope của chính arrow function\n\n  - `this` trong arrow function sẽ giống với `this` ở parent scope.\n  - `this` không thể thay đổi bằng `.call`, `.apply`, hoặc là các phương thức tương tự.\n\n> Xem thêm: [http://kipalog.com/posts/ECMA-Script-6-fat-arrow-function]\n\n# Template Literals\n\n- Bạn có thể định nghĩa chuỗi với dấu `` ` `` (backtick), thay vì kiểu cũ là `\"` và `'`\n- Chuỗi mà bao trong dấu backtick gọi là template literals\n- Template literals có thể gồm nhiều dòng\n- Template literals cho phép bạn đặt biến vào thế này `khoanguyen.me is ${rating}` (với `rating` là một biến)\n- Bạn có thể đặt vào bất cứ thứ gì hợp lệ với Javascript trong cặp ngoặc như `${2 * 3}` hoặc `${foo()}`\n- Bạn có thể thay đổi kết quả kết template literals\n\n  - Thêm vào trước `fn` thế này ``fn`foo, ${bar} and ${baz}```\n  - `fn` sẽ được gọi với tham số  `template, ...expressions`\n  - `template` là `['foo, ', ' and ', '']` và `expressions` là `[bar, baz]`\n  - Kết quả trả về của `fn` sẽ trở thành giá trị của template literal.\n- Tổng kết lại thì định nghĩa chuỗi với template literals tốt hơn so với việc dùng cặp nháy đơn hay nháy kép\n\n# Object Literals\n\n- Thay vì phải viết `{ foo: foo }`, bây giờ bạn chỉ cần viết  `{ foo }` – đây được gọi *property value shorthand* (tạm dịch: định nhanh giá trị của thuộc tính)\n- Tính toán tên thuộc tính (*Computed property names*), `{ [prefix + 'Foo']: 'bar' }`, khi `prefix: 'moz'`, sẽ cho ra kết quả `{ mozFoo: 'bar' }`\n- Bạn không thể kết hợp computed property names và property value shorthands, `{ [foo] }` là không hợp lệ\n- Bạn có thể định method cho object literal bằng cú pháp nhanh này: `{ foo () {} }`\n\n# Class\n\n- Không phải là class như OOP, chỉ là một cú pháp gọn hơn dựa trên prototype\n- Cú pháp giống như định object `class Foo {}`\n- Instance methods – `new Foo().bar` – được định nghĩa nhờ cú pháp *object literal* như trên `class Foo { bar () {} }`\n- Static methods – `Foo.isPonyFoo()` – cần thêm `static` vào trước, `class Foo { static isPonyFoo () {} }`\n- Constructor  `class Foo { constructor () { /* initialize instance */ } }`\n- Thừa kế nhờ cấu trúc thế này `class PonyFoo extends Foo {}`\n\n# Let và Const\n\n- `let` và `const` là hai cách khác ngoài `var` để khởi tạo biến.\n- `let` là `block-scoped` thay vì `lexically scoped` như hàm.\n- `let` gắn với `block` hiện tại, trong khi `var` gắn với `block` của hàm\n- “Temporal Dead Zone” (gọi tắt TDZ)\n\n  - Bắt đầu ở `block` mà `let foo` được khởi tạo\n  - Kết thúc khi thực hiện câu lệnh khởi tạo `let foo`\n  - Cố gắng truy cập hoặc gán biến trong vùng TDZ (tức là trước câu lên `let foo`) sẽ gây ra lỗi\n  - Giúp tránh các lỗi đau đầu khi biến bị thay đổi trước khi nó được khởi tạo (có thể hiểu như là `\"use strict\"`)\n- `const` cũng là `block-scoped` gắn và ràng buộc bởi TDZ\n- Khi dùng `const`, biến cần phải gắn giá trị ngay khi khởi tạo `const foo = 'bar'`\n- Gán giá trị cho `const` sau khi khởi tạo sẽ gây lỗi một ách im lặng hay `throw` trong `\"use strict\"`.\n- Giá trị của biến `const` không phải là hằng định (immutable)\n\n  - `const foo = { bar: 'baz' }; foo.bar = 'boo'` sẽ không `throw` lỗi\n- Khởi tạo biến cùng tên sẽ `throw` lỗi\n- Định tạo ra để khắc phục vấn đề ghi đè biến.\n\n# Symbol\n\n- Một kiểu dữ liệu mới của ES6\n- Bạn có thể khởi tạo symbol thế này `var symbol = Symbol()`\n- Bạn có thể thêm chú thích để dễ debug `Symbol('ponyfoo')`\n- Symbol là hằng định và độc nhất. `Symbol(), Symbol(), Symbol('foo') và Symbol('foo')` cả 4 giá trị trên khác nhau hoàn toàn.\n- `typeof Symbol() === 'symbol'`\n- You can also create global symbols with Symbol.for(key)\nIf a symbol with the provided key already existed, you get that one back\nOtherwise, a new symbol is created, using key as its description as well\nSymbol.keyFor(symbol) is the inverse function, taking a symbol and returning its key\nGlobal symbols are as global as it gets, or cross-realm. Single registry used to look up these symbols across the runtime\n`window context`\n`eval context`\n`<iframe> context, Symbol.for('foo') === iframe.contentWindow.Symbol.for('foo')`\nThere’s also “well-known” symbols\nNot on the global registry, accessible through Symbol[name], e.g: Symbol.iterator\nCross-realm, meaning Symbol.iterator === iframe.contentWindow.Symbol.iterator\nUsed by specification to define protocols, such as the iterable protocol over Symbol.iterator\nThey’re not actually well-known – in colloquial terms\nIterating over symbol properties is hard, but not impossible and definitely not private\nSymbols are hidden to all pre-ES6 “reflection” methods\nSymbols are accessible through Object.getOwnPropertySymbols\nYou won’t stumble upon them but you will find them if actively looking\n","__filename":"es6.md","__url":"/es6/","__resourceUrl":"/es6/index.html","__dataUrl":"/es6/index.html.dec750c93567f29d43f8c0049af36cf4.json"}
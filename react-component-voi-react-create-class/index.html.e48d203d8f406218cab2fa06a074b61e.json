{"head":{"layout":"Post","title":"React.Component với React.createClass","date":"2016-02-19T00:39:00.000Z","tags":["reactjs"],"translate":{"url":"http://reactjsnews.com/composing-components/","author":"Naman Goel & Zach Silveira"},"description":"Giới thiệu React hỗ trợ 2 cách để tạo Component. Bạn có thể kế thừa từ class React.Component hoặc là dùng cú pháp cũ React.createClass đã…"},"body":"<h1 id=\"giới-thiệu\"><a href=\"#gi%E1%BB%9Bi-thi%E1%BB%87u\" class=\"phenomic-HeadingAnchor\">#</a>Giới thiệu</h1>\n<p>React hỗ trợ 2 cách để tạo Component.\nBạn có thể kế thừa từ class <code>React.Component</code> hoặc là\ndùng cú pháp cũ <code>React.createClass</code> đã có từ khi React ra đời.\nCó lí do nào cụ thể để dùng một cú pháp thay vì cú pháp còn lại?</p>\n<p>Thực tế, nó hoàn toàn phụ thuộc vào bạn.</p>\n<p>Theo quan điểm của mình thì nó chẳng có khác biệt gì lớn.\nTrong hầu hết mọi trường hợp, sự khác biệt giữa <code>React.createClass</code>\nvà <code>class X extends React.Component</code> chỉ là cú pháp. Nếu bạn\nkhông dùng mixin hoặc decorator thường xuyên thì chỉ việc dùng cấu\ntrúc nào bạn thích nhất.</p>\n<p>Ngoài ra, có vài lí do thực sự buộc bạn phải chọn một cú pháp\nnhất định.</p>\n<p>Có vài tính năng bạn sẽ không thể sử dụng khi dùng ES6 class như là\nmixin, hàm autoBound và <code>this.isMounted</code>. ES6 class cũng có nghĩa là\nbạn sẽ phải phụ thuộc vào một công cụ build (như Babel). Nếu bạn\nkhông dùng JSX, và đã viết ES5 code không cần chuyển đổi, đây thực\nsự là một lí do quan trọng.</p>\n<p>Nhưng trước khi nêu ra những ưu điểm và nhược điểm,\ncần phải nói rõ rằng dùng ES6 class thay vì <code>React.createClass</code>\nKHÔNG làm code của bạn mất đi, hoặc có thêm tính hướng đối tượng\n(Object oriented). Nó chỉ là sự khác biệt về cú pháp, nó có ít tính\nnăng hơn, nhưng điều quan trọng là bạn đang dùng\n<code>constructor pattern</code> thay vì <code>factory pattern</code>. Vì vậy, nếu bạn muốn\ncode của bạn rõ ràng hơn, đây chính là một điều không thể bàn cãi đối với bạn.</p>\n<p>Mặt khác, ES6 class giúp bạn có thể dễ dàng thừa kế (inheritane).\nNhưng mình khuyên là đừng làm như vậy, hãy bỏ ngay ý tưởng dùng\nES6 class chỉ để thực hiện một chuỗi thừa kế dài, hãy dùng\n<code>React.createClass</code> và kèm với mixin.</p>\n<h1 id=\"lí-do-để-dùng-reactcreateclass\"><a href=\"#l%C3%AD-do-%C4%91%E1%BB%83-d%C3%B9ng-reactcreateclass\" class=\"phenomic-HeadingAnchor\">#</a>Lí do để dùng <code>React.createClass</code></h1>\n<h2 id=\"tôi-thích-hàm-auto-binding\"><a href=\"#t%C3%B4i-th%C3%ADch-h%C3%A0m-auto-binding\" class=\"phenomic-HeadingAnchor\">#</a>\"Tôi thích hàm auto-binding\"</h2>\n<p>Đây là một lí do chính đáng, tuy nhiên bạn có thể autobind với ES6 class\n<a href=\"https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding\">(bài viết từ React)</a></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span> () {\n    <span class=\"hljs-keyword\">super</span>();\n    <span class=\"hljs-keyword\">this</span>.tick = <span class=\"hljs-keyword\">this</span>.tick.bind(<span class=\"hljs-keyword\">this</span>);\n  }\n  tick () {\n    ...\n  }\n  ...\n}</code></pre>\n<p>Sử dụng Babel <code>stage: 0</code> bạn có thể viết class như thế này:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  tick = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n    ...\n  }\n  ...\n}</code></pre>\n<p>Nếu bạn không thích <code>stage: 0</code>, có lựa chọn khác dành cho bạn.\nVí dụ như là dùng\n<a href=\"https://github.com/andreypopp/autobind-decorator\">autobind decorator</a></p>\n<p>Decorator cũng là <code>stage: 0</code> nhưng bạn thực sự không cần stage 0\ndể dùng <code>autobind decorator</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  tick () {\n    ...\n  }\n  ...\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> autobind(Counter)</code></pre>\n<h2 id=\"tôi-thích-mixins\"><a href=\"#t%C3%B4i-th%C3%ADch-mixins\" class=\"phenomic-HeadingAnchor\">#</a>\"Tôi thích mixins\"</h2>\n<p>Đây gần như là lí do chính mọi người vẫn sử dụng <code>React.createClass</code>.\nCó rất nhiều code React vẫn còn dựa trên mixins. Tuy nhiên, bạn có thể dùng\n<a href=\"https://www.npmjs.com/package/react-mixin\">React-mixin</a>\nđể có mixin với ES6 class</p>\n<h2 id=\"thisismounted\"><a href=\"#thisismounted\" class=\"phenomic-HeadingAnchor\">#</a><code>this.isMounted</code></h2>\n<p>Bạn chẳng bao giờ sử dụng <code>this.isMounted</code> cả, và khi bạn cần, nó\ncũng rất dễ để thêm vào.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  componentDidMount () {\n    <span class=\"hljs-keyword\">this</span>.isMounted = <span class=\"hljs-literal\">true</span>\n  }\n  tick () {\n    ...\n  }\n  ...\n}</code></pre>\n<p>Bản thân mình chẳng bao giờ sử dụng tính năng này.</p>\n<h1 id=\"lí-do-để-chuyển-sang-dùng-cú-pháp-es6\"><a href=\"#l%C3%AD-do-%C4%91%E1%BB%83-chuy%E1%BB%83n-sang-d%C3%B9ng-c%C3%BA-ph%C3%A1p-es6\" class=\"phenomic-HeadingAnchor\">#</a>Lí do để chuyển sang dùng cú pháp ES6</h1>\n<h2 id=\"autobinding\"><a href=\"#autobinding\" class=\"phenomic-HeadingAnchor\">#</a>Autobinding?</h2>\n<p>Vấn đề về <code>context</code> trong Javascript khá là nhức nhối. Việc\ntự động <code>autobinding</code> được <code>React.createClass</code> thực hiện đôi\nkhi gây khó hiểu cho những bạn mới làm quên, và sự rắc rối của\nbinding có thể làm bạn khó hiểu trong nhiều tháng liền.\nVới ES6 class, bạn phải tự thực hiện binding. Điều này giúp\ncode của bạn rõ ràng hơn, ít \"thần kì\" hơn. Và sẽ giúp cho các\nlập trình viên mới tiếp xúc với React biết thực \"chuyện gì đang xảy ra\". Bằng sự trợ giúp của Babel với các tính năng của\nES6/7, binding thủ công không còn là một vấn đề lớn.</p>\n<h2 id=\"bỏ-qua-mixins-hãy-dùng-higher-order-components\"><a href=\"#b%E1%BB%8F-qua-mixins-h%C3%A3y-d%C3%B9ng-higher-order-components\" class=\"phenomic-HeadingAnchor\">#</a>Bỏ qua Mixins, hãy dùng Higher-Order-Components</h2>\n<p>Nếu bạn có xem qua bất cứ thảo luận nào về ES6 class, bạn sẽ\nthấy mọi người nói bạn dùng <strong>kết hợp</strong> (composition) thay cho <strong>thừa kế</strong>.\nBạn có thể đã thấy meme này</p>\n<p><img src=\"/images/2016/react-component-vs-create-class/compose-all-the-things.png\" alt=\"compose all the things\"></p>\n<p>Sự thật thì thừa kế là một cách tồi tệ để viết code. Nó đến lỗi, lỗi thời và khó hiểu. Nó buộc bạn phải viết theo một\ncách giống nhau. Mixins chắc chắn là một giải phải tốt hơn\n(thừa kế), nhưng các lập trình viện thừa lạm dụng chúng để\nlàm những thứ có thể dễ dàng đạt được với kết hợp. Và điều\nquan trọng nhất là Higher-Order-Component có thể dùng với cả\nhai cách tạo Component và cả pure functions.</p>\n<blockquote>\n<p>Đọc thêm\n<a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.ki6u85yvc\">Mixins are dead long live higher oder components</a></p>\n</blockquote>\n<h2 id=\"không-còn-code-thừa-no-cruft\"><a href=\"#kh%C3%B4ng-c%C3%B2n-code-th%E1%BB%ABa-no-cruft\" class=\"phenomic-HeadingAnchor\">#</a>Không còn code thừa (No Cruft)</h2>\n<p>Loại bỏ những tính năng hiếm khi sử dụng như <code>this.isMounted</code>\nsẽ giúp React nhẹ hơn và linh hoạt hơn. Theo thời gian, điều\nnày sẽ giúp React nhanh hơn. Mình biết là tất cả chúng ta đều\nyêu React, nhưng chúng ta cũng muốn có tốc độ phải không nào ?</p>\n<h2 id=\"flowtypes\"><a href=\"#flowtypes\" class=\"phenomic-HeadingAnchor\">#</a>FlowTypes</h2>\n<p>Đây là điều mà mình thích nhất. Trong một thời gian dài, mình\nđã cố tình bỏ qua Typescript và Flow, nhưng sau khi mất nguyên\nmột ngày vì gõ sai tên <code>sự kiện</code> (event), mình bắt đầu dùng\nFlow và chưa bao giờ nhìn lại. Flow giúp bạn thực hiện chuyển\nđổi một cách chậm chạp, theo từng file. Và đừng xem thường, nó\nsẽ giúp bạn tìm ra hàng tá lỗi mà bạn chưa từng biết đến sự\ntồn tại.</p>\n<p>Nhưng điều này giúp ích gì khi dùng ES6 class ?\nFlowtype và Typescript sẽ dễ dàng hơn nếu bạn đang dùng ES6 class.</p>\n<p>Đây là một ví dụ:</p>\n<p>ES6 class</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">X</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  someProp: string | number;\n  state: SomeType;\n  props: SomeType;\n  ...\n}</code></pre>\n<p>React.createClass</p>\n<pre><code class=\"hljs language-js\">React.createClass({\n  <span class=\"hljs-attr\">someProp</span>: (<span class=\"hljs-number\">0</span>: string | number),\n  ...\n})</code></pre>\n<p>Và sự thật là bạn không thể định kiểu (type) cho props và state với\nflow khi dùng React.createClass. Thay và đó, Flow phụ thuộc\nvào hàng tá code để có thể xác định kiểu bằng việc đọc <code>propTypes</code>.\nThực tế thì nó chưa bao giờ làm tốt như vậy. Và đừng có nghĩ đến việc\nkiểm tra kiểu (type checking) với state. Nó đơn giản là không thể.</p>\n<h1 id=\"kết-luận\"><a href=\"#k%E1%BA%BFt-lu%E1%BA%ADn\" class=\"phenomic-HeadingAnchor\">#</a>Kết luận</h1>\n<p>Cả 2 kiểu tạo component như trên đều sẽ không biến mất trong\ntương lại gần. Nếu ES6 class trở thành cách mà mọi người chọn\nthay vì <code>createClass</code>, Javascript cần nhiều hơn là một <code>sugar syntax</code>\n(tạm dịch là cú pháp thân thuộc), nó cần <code>class</code> thực sự.\nMình chọn viết component bằng ES6 class vì nó nhìn gọn hơn,\nkhông cần đặt dấu phẩy và sau mỗi hàm, và những điều hạn chế\nkể trên với cú pháp này không ảnh hướng nhiều đến mình.</p>\n","__filename":"react-component-voi-react-create-class.md","__url":"/react-component-voi-react-create-class/","__resourceUrl":"/react-component-voi-react-create-class/index.html","__dataUrl":"/react-component-voi-react-create-class/index.html.e48d203d8f406218cab2fa06a074b61e.json"}
<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/phenomic.browser.23f04e7a39b6760c1f26.css" /><meta data-react-helmet="true" property="og:site_name" content="Khoa Nguyen Blog"/><meta data-react-helmet="true" name="twitter:site" content="@khoanguyenme"/><meta data-react-helmet="true" name="theme-color" content="#0275d8"/><meta data-react-helmet="true" name="msapplication-TileColor" content="#0275d8"/><meta data-react-helmet="true" property="og:title" content="React.Component với React.createClass - Khoa Nguyen Blog"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:url" content="https://khoanguyen.me/react-component-voi-react-create-class/"/><meta data-react-helmet="true" property="og:description" content="Giới thiệu React hỗ trợ 2 cách để tạo Component. Bạn có thể kế thừa từ class React.Component hoặc là dùng cú pháp cũ React.createClass đã có từ khi React ra đời. Có lí do nào cụ thể để dùng một cú…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="React.Component với React.createClass - Khoa Nguyen Blog"/><meta data-react-helmet="true" name="twitter:creator" content="@khoanguyenme"/><meta data-react-helmet="true" name="twitter:description" content="Giới thiệu React hỗ trợ 2 cách để tạo Component. Bạn có thể kế thừa từ class React.Component hoặc là dùng cú pháp cũ React.createClass đã có từ khi React ra đời. Có lí do nào cụ thể để dùng một cú…"/><meta data-react-helmet="true" name="description" content="Giới thiệu React hỗ trợ 2 cách để tạo Component. Bạn có thể kế thừa từ class React.Component hoặc là dùng cú pháp cũ React.createClass đã có từ khi React ra đời. Có lí do nào cụ thể để dùng một cú…"/><title data-react-helmet="true">React.Component với React.createClass</title></head><body><div id="phenomic"><div data-reactroot="" data-reactid="1" data-react-checksum="295063131"><!-- react-empty: 2 --><div style="margin-bottom:2rem;" class="headroom-wrapper" data-reactid="3"><div style="position:relative;top:0;left:0;right:0;z-index:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);transform:translateY(0);background:#0275d8;box-shadow:1px 2px 2px #aaa;" class="headroom headroom--unfixed" data-reactid="4"><div class="MFe5B" data-reactid="5"><div class="_f1jz" data-reactid="6"><a class="" href="/" data-reactid="7">Khoa Nguyen</a></div><a class="_1djP0" href="/archive/" data-reactid="8"><i class="icon-bookmark" data-reactid="9"></i><span data-reactid="10">Bài viết</span></a><a class="_1djP0" href="/about/" data-reactid="11"><i class="icon-user" data-reactid="12"></i><span data-reactid="13">Giới thiệu</span></a><a href="https://github.com/thangngoc89" target="_blank" class="_1djP0" data-reactid="14"><i class="icon-github" data-reactid="15"></i><span data-reactid="16">Github</span></a><div class="_38hOm" data-reactid="17"><input type="search" placeholder="search..." data-reactid="18"/></div></div></div></div><div data-reactid="19"><div class="container" data-reactid="20"><!-- react-empty: 21 --><!-- react-empty: 22 --><div class="row" data-reactid="23"><div class="LRFOR center-block" data-reactid="24"><h1 class="_1s9g9" data-reactid="25">React.Component với React.createClass</h1><span class="_3gT92" data-reactid="26">19 tháng 2 2016</span><span class="_3j9fr" data-reactid="27"><!-- react-text: 28 -->~ <!-- /react-text --><!-- react-text: 29 -->6 phút<!-- /react-text --></span><article class="bSe9a" data-reactid="30"><h1 id="Gioi-thieu"><a class="markdownIt-Anchor" href="#Gioi-thieu">#</a> Giới thiệu</h1>
<p>React hỗ trợ 2 cách để tạo Component.
Bạn có thể kế thừa từ class <code>React.Component</code> hoặc là
dùng cú pháp cũ <code>React.createClass</code> đã có từ khi React ra đời.
Có lí do nào cụ thể để dùng một cú pháp thay vì cú pháp còn lại?</p>
<p>Thực tế, nó hoàn toàn phụ thuộc vào bạn.</p>
<p>Theo quan điểm của mình thì nó chẳng có khác biệt gì lớn.
Trong hầu hết mọi trường hợp, sự khác biệt giữa <code>React.createClass</code>
và <code>class X extends React.Component</code> chỉ là cú pháp. Nếu bạn
không dùng mixin hoặc decorator thường xuyên thì chỉ việc dùng cấu
trúc nào bạn thích nhất.</p>
<p>Ngoài ra, có vài lí do thực sự buộc bạn phải chọn một cú pháp
nhất định.</p>
<p>Có vài tính năng bạn sẽ không thể sử dụng khi dùng ES6 class như là
mixin, hàm autoBound và <code>this.isMounted</code>. ES6 class cũng có nghĩa là
bạn sẽ phải phụ thuộc vào một công cụ build (như Babel). Nếu bạn
không dùng JSX, và đã viết ES5 code không cần chuyển đổi, đây thực
sự là một lí do quan trọng.</p>
<p>Nhưng trước khi nêu ra những ưu điểm và nhược điểm,
cần phải nói rõ rằng dùng ES6 class thay vì <code>React.createClass</code>
KHÔNG làm code của bạn mất đi, hoặc có thêm tính hướng đối tượng
(Object oriented). Nó chỉ là sự khác biệt về cú pháp, nó có ít tính
năng hơn, nhưng điều quan trọng là bạn đang dùng
<code>constructor pattern</code> thay vì <code>factory pattern</code>. Vì vậy, nếu bạn muốn
code của bạn rõ ràng hơn, đây chính là một điều không thể bàn cãi đối với bạn.</p>
<p>Mặt khác, ES6 class giúp bạn có thể dễ dàng thừa kế (inheritane).
Nhưng mình khuyên là đừng làm như vậy, hãy bỏ ngay ý tưởng dùng
ES6 class chỉ để thực hiện một chuỗi thừa kế dài, hãy dùng
<code>React.createClass</code> và kèm với mixin.</p>
<h1 id="Li-do-de-dung-ReactcreateClass"><a class="markdownIt-Anchor" href="#Li-do-de-dung-ReactcreateClass">#</a> Lí do để dùng <code>React.createClass</code></h1>
<h2 id="Toi-thich-ham-auto-binding"><a class="markdownIt-Anchor" href="#Toi-thich-ham-auto-binding">#</a> “Tôi thích hàm auto-binding”</h2>
<p>Đây là một lí do chính đáng, tuy nhiên bạn có thể autobind với ES6 class
<a href="https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding">(bài viết từ React)</a></p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span> () {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.tick = <span class="hljs-keyword">this</span>.tick.bind(<span class="hljs-keyword">this</span>);
  }
  tick () {
    ...
  }
  ...
}</code></pre>
<p>Sử dụng Babel <code>stage: 0</code> bạn có thể viết class như thế này:</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  tick = () =&gt; {
    ...
  }
  ...
}</code></pre>
<p>Nếu bạn không thích <code>stage: 0</code>, có lựa chọn khác dành cho bạn.
Ví dụ như là dùng
<a href="https://github.com/andreypopp/autobind-decorator">autobind decorator</a></p>
<p>Decorator cũng là <code>stage: 0</code> nhưng bạn thực sự không cần stage 0
dể dùng <code>autobind decorator</code></p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  tick () {
    ...
  }
  ...
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> autobind(Counter)</code></pre>
<h2 id="Toi-thich-mixins"><a class="markdownIt-Anchor" href="#Toi-thich-mixins">#</a> “Tôi thích mixins”</h2>
<p>Đây gần như là lí do chính mọi người vẫn sử dụng <code>React.createClass</code>.
Có rất nhiều code React vẫn còn dựa trên mixins. Tuy nhiên, bạn có thể dùng
<a href="https://www.npmjs.com/package/react-mixin">React-mixin</a>
để có mixin với ES6 class</p>
<h2 id="thisisMounted"><a class="markdownIt-Anchor" href="#thisisMounted">#</a> <code>this.isMounted</code></h2>
<p>Bạn chẳng bao giờ sử dụng <code>this.isMounted</code> cả, và khi bạn cần, nó
cũng rất dễ để thêm vào.</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount () {
    <span class="hljs-keyword">this</span>.isMounted = <span class="hljs-literal">true</span>
  }
  tick () {
    ...
  }
  ...
}</code></pre>
<p>Bản thân mình chẳng bao giờ sử dụng tính năng này.</p>
<h1 id="Li-do-de-chuyen-sang-dung-cu-phap-ES6"><a class="markdownIt-Anchor" href="#Li-do-de-chuyen-sang-dung-cu-phap-ES6">#</a> Lí do để chuyển sang dùng cú pháp ES6</h1>
<h2 id="Autobinding"><a class="markdownIt-Anchor" href="#Autobinding">#</a> Autobinding?</h2>
<p>Vấn đề về <code>context</code> trong Javascript khá là nhức nhối. Việc
tự động <code>autobinding</code> được <code>React.createClass</code> thực hiện đôi
khi gây khó hiểu cho những bạn mới làm quên, và sự rắc rối của
binding có thể làm bạn khó hiểu trong nhiều tháng liền.
Với ES6 class, bạn phải tự thực hiện binding. Điều này giúp
code của bạn rõ ràng hơn, ít “thần kì” hơn. Và sẽ giúp cho các
lập trình viên mới tiếp xúc với React biết thực “chuyện gì đang xảy ra”. Bằng sự trợ giúp của Babel với các tính năng của
ES6/7, binding thủ công không còn là một vấn đề lớn.</p>
<h2 id="Bo-qua-Mixins-hay-dung-Higher-Order-Components"><a class="markdownIt-Anchor" href="#Bo-qua-Mixins-hay-dung-Higher-Order-Components">#</a> Bỏ qua Mixins, hãy dùng Higher-Order-Components</h2>
<p>Nếu bạn có xem qua bất cứ thảo luận nào về ES6 class, bạn sẽ
thấy mọi người nói bạn dùng <strong>kết hợp</strong> (composition) thay cho <strong>thừa kế</strong>.
Bạn có thể đã thấy meme này</p>
<p><img src="/images/2016/react-component-vs-create-class/compose-all-the-things.png" alt="compose all the things"></p>
<p>Sự thật thì thừa kế là một cách tồi tệ để viết code. Nó đến lỗi, lỗi thời và khó hiểu. Nó buộc bạn phải viết theo một
cách giống nhau. Mixins chắc chắn là một giải phải tốt hơn
(thừa kế), nhưng các lập trình viện thừa lạm dụng chúng để
làm những thứ có thể dễ dàng đạt được với kết hợp. Và điều
quan trọng nhất là Higher-Order-Component có thể dùng với cả
hai cách tạo Component và cả pure functions.</p>
<blockquote>
<p>Đọc thêm
<a href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.ki6u85yvc">Mixins are dead long live higher oder components</a></p>
</blockquote>
<h2 id="Khong-con-code-thua-No-Cruft"><a class="markdownIt-Anchor" href="#Khong-con-code-thua-No-Cruft">#</a> Không còn code thừa (No Cruft)</h2>
<p>Loại bỏ những tính năng hiếm khi sử dụng như <code>this.isMounted</code>
sẽ giúp React nhẹ hơn và linh hoạt hơn. Theo thời gian, điều
này sẽ giúp React nhanh hơn. Mình biết là tất cả chúng ta đều
yêu React, nhưng chúng ta cũng muốn có tốc độ phải không nào ?</p>
<h2 id="FlowTypes"><a class="markdownIt-Anchor" href="#FlowTypes">#</a> FlowTypes</h2>
<p>Đây là điều mà mình thích nhất. Trong một thời gian dài, mình
đã cố tình bỏ qua Typescript và Flow, nhưng sau khi mất nguyên
một ngày vì gõ sai tên <code>sự kiện</code> (event), mình bắt đầu dùng
Flow và chưa bao giờ nhìn lại. Flow giúp bạn thực hiện chuyển
đổi một cách chậm chạp, theo từng file. Và đừng xem thường, nó
sẽ giúp bạn tìm ra hàng tá lỗi mà bạn chưa từng biết đến sự
tồn tại.</p>
<p>Nhưng điều này giúp ích gì khi dùng ES6 class ?
Flowtype và Typescript sẽ dễ dàng hơn nếu bạn đang dùng ES6 class.</p>
<p>Đây là một ví dụ:</p>
<p>ES6 class</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  someProp: string | number;
  state: SomeType;
  props: SomeType;
  ...
}</code></pre>
<p>React.createClass</p>
<pre><code class="language-js">React.createClass({
  someProp: (<span class="hljs-number">0</span>: string | number),
  ...
})</code></pre>
<p>Và sự thật là bạn không thể định kiểu (type) cho props và state với
flow khi dùng React.createClass. Thay và đó, Flow phụ thuộc
vào hàng tá code để có thể xác định kiểu bằng việc đọc <code>propTypes</code>.
Thực tế thì nó chưa bao giờ làm tốt như vậy. Và đừng có nghĩ đến việc
kiểm tra kiểu (type checking) với state. Nó đơn giản là không thể.</p>
<h1 id="Ket-luan"><a class="markdownIt-Anchor" href="#Ket-luan">#</a> Kết luận</h1>
<p>Cả 2 kiểu tạo component như trên đều sẽ không biến mất trong
tương lại gần. Nếu ES6 class trở thành cách mà mọi người chọn
thay vì <code>createClass</code>, Javascript cần nhiều hơn là một <code>sugar syntax</code>
(tạm dịch là cú pháp thân thuộc), nó cần <code>class</code> thực sự.
Mình chọn viết component bằng ES6 class vì nó nhìn gọn hơn,
không cần đặt dấu phẩy và sau mỗi hàm, và những điều hạn chế
kể trên với cú pháp này không ảnh hướng nhiều đến mình.</p>
</article><a href="http://reactjsnews.com/composing-components/" target="_blank" class="_1kFcH" data-reactid="31"><!-- react-text: 32 -->Translated from original post by <!-- /react-text --><!-- react-text: 33 -->Naman Goel &amp; Zach Silveira<!-- /react-text --></a><div class="_2M5DN" data-reactid="34"><a href="/cau-lenh-bash-duoc-ban-dung-nhieu-nhat/" data-reactid="35"><i class="icon-left-open-big" data-reactid="36"></i><!-- react-text: 37 -->Câu lệnh Bash bạn hay sử dụng<!-- /react-text --></a></div><div class="_3ts3L" data-reactid="38"><a href="/json-js/" data-reactid="39"><!-- react-text: 40 -->json ⊄ js<!-- /react-text --><i class="icon-right-open-big" data-reactid="41"></i></a></div><p class="_3iv3I" data-reactid="42"><!-- react-text: 43 -->Bài viết sai chính tả? Có điểm chưa rõ ràng?<!-- /react-text --><!-- react-text: 44 -->  <!-- /react-text --><a href="https://github.com/thangngoc89/blog-posts/blob/master/react-component-voi-react-create-class.md" target="_blank" data-reactid="45">Sửa bài viết trên Github</a></p><div data-reactid="46"><div class="_7159-" style="height:10rem;" data-reactid="47">Loading Disqus...</div></div></div></div></div></div><footer class="_3WpLN" data-reactid="48"><div class="row" data-reactid="49"><div class="_18mzr" data-reactid="50"><p data-reactid="51"><!-- react-text: 52 -->Built with<!-- /react-text --><span class="_25_q4" data-reactid="53"> ♥ </span><!-- react-text: 54 -->by Khoa Nguyen<!-- /react-text --></p><p data-reactid="55"><a target="_blank" href="https://github.com/thangngoc89/blog" data-reactid="56">Source code available under MIT License</a></p></div><div class="_3LfEc" data-reactid="57"><p data-reactid="58">Copyright©2015-present, Khoa Nguyen</p></div></div></footer></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.621d497b9b3643e03358f2d161e79b45.json"},{"title":"Giới thiệu","layout":"Page","description":"Vài điều cơ bản về mình Mình là Khoa Mình học ngành Y Mình thích viết blog và lập trình Lập trình rất vui Hãy như Khoa Ngôn ngữ ? Mình chủ yếu tìm hiểu về viết web. Các ngôn ngữ mình dùng…","__filename":"about.md","__url":"/about/","__resourceUrl":"/about/index.html","__dataUrl":"/about/index.html.c491930b075324c5239a45665412fa4e.json"},{"title":"Bài viết","layout":"Archive","description":"","__filename":"archive.md","__url":"/archive/","__resourceUrl":"/archive/index.html","__dataUrl":"/archive/index.html.a54aadf9cd03f26463ab665192553082.json"},{"layout":"Post","title":"[Black Friday 2014] Namecheap giảm giá Domain/Hosting chỉ còn $0.98","date":"2014-11-27T13:49:22.000Z","tags":["namecheap","domain","black-friday"],"toc":false,"description":"namecheap Hưởng ứng Black Friday năm nay Namecheap đã mang đến cho người dùng coupon giảm giá còn $0.98/năm cho việc thanh toán khi đăng ký hoặc transfer domain các loại. Các khuyến mãi cụ thể mà…","__filename":"black-friday-2014-namecheap-giam-gia-domainhosting-chi-con-0-98.md","__url":"/black-friday-2014-namecheap-giam-gia-domainhosting-chi-con-0-98/","__resourceUrl":"/black-friday-2014-namecheap-giam-gia-domainhosting-chi-con-0-98/index.html","__dataUrl":"/black-friday-2014-namecheap-giam-gia-domainhosting-chi-con-0-98/index.html.bf30f56b4f55d1a55a7ea77edb73abf6.json"},{"layout":"Post","title":"Blog mình thường đọc","date":"2015-03-15T06:00:00.000Z","description":"Tập hợp blog mình thích đọc và follow ","tags":["link"],"toc":false,"__filename":"blog-minh-thuong-doc.md","__url":"/blog-minh-thuong-doc/","__resourceUrl":"/blog-minh-thuong-doc/index.html","__dataUrl":"/blog-minh-thuong-doc/index.html.3df1ef9ddd991a34e96847fcbdb72517.json"},{"layout":"Post","title":"[BOT] MultiTools Paidverts & BTCClicks & ProBux v3","date":"2014-11-16T09:48:08.000Z","tags":["mmo","bot"],"description":"MultiTools for Paidverts BTCClicks Probux Mở đầu Trong bài này mình sẽ hướng dẫn các bạn sử dụng MultiTools của tác giả Bloons97. Đây là một bot mạnh mẽ được viết trên C# và được tác giả cập nhật…","__filename":"bot-multitools-paidverts-btcclicks-probux-v3.md","__url":"/bot-multitools-paidverts-btcclicks-probux-v3/","__resourceUrl":"/bot-multitools-paidverts-btcclicks-probux-v3/index.html","__dataUrl":"/bot-multitools-paidverts-btcclicks-probux-v3/index.html.ecba6237f2825a312034b59c1ffd5542.json"},{"layout":"Post","title":"Cách xem quảng cáo trên Paidverts","date":"2014-11-15T22:24:03.000Z","tags":["mmo"],"description":"Trong bài trước mình đã Giới thiệu cơ bản về PaidVerts. Trong bài này mình sẽ tiếp tục hướng dẫn cách xem quảng cáo trên PaidVerts. Hướng dẫn xem quảng cáo trên PaidVerts Truy cập vào https&#x3A…","__filename":"cach-xem-quang-cao-tren-paidverts.md","__url":"/cach-xem-quang-cao-tren-paidverts/","__resourceUrl":"/cach-xem-quang-cao-tren-paidverts/index.html","__dataUrl":"/cach-xem-quang-cao-tren-paidverts/index.html.7370aa93d37d4b6ebc0309df2ebbd852.json"},{"layout":"Post","title":"[Laravel cơ bản] Cài đặt Laravel","date":"2015-01-05T19:36:03.000Z","description":"Cài đặt Laravel - Series Laravel cơ bản","tags":["laravel"],"__filename":"cai-dat-laravel.md","__url":"/cai-dat-laravel/","__resourceUrl":"/cai-dat-laravel/index.html","__dataUrl":"/cai-dat-laravel/index.html.2666df64f2268819bf32bd8afd1f39d2.json"},{"layout":"Post","title":"Cài đặt Node.JS trên Windows","date":"2015-01-05T04:48:11.000Z","tags":["js"],"toc":false,"description":"Hôm qua mình có cài lại máy, kéo theo đó là một số chương trình cho việc lập trình trong đó có NodeJS. Nhưng mà khi cài vào mình phải dùng Node.JS Command Prompt được đi kèm thì mới gọi được lệnh…","__filename":"cai-dat-nodejs-tren-windows.md","__url":"/cai-dat-nodejs-tren-windows/","__resourceUrl":"/cai-dat-nodejs-tren-windows/index.html","__dataUrl":"/cai-dat-nodejs-tren-windows/index.html.39669b620ca2be25129da44ac148da34.json"},{"layout":"Post","title":"Cài đặt Wine chạy các ứng dụng Windows trên Ubuntu","date":"2014-11-16T13:31:45.000Z","tags":["vps"],"description":"Mở đầu Chắc hẳn các bạn ai cũng biết, giá VPS linux thường rẻ hơn VPS Windows (phí bản quyền) nhưng hầu hết các ứng dụng kiếm tiền (cũng như các ứng dụng cơ bản khác) đều chỉ có thể chạy trên Windows…","__filename":"cai-dat-wine-tren-ubuntu.md","__url":"/cai-dat-wine-tren-ubuntu/","__resourceUrl":"/cai-dat-wine-tren-ubuntu/index.html","__dataUrl":"/cai-dat-wine-tren-ubuntu/index.html.368edf38d58da387a4231e3b0de8d376.json"},{"layout":"Post","title":"Câu lệnh Bash bạn hay sử dụng","date":"2016-01-26T07:00:00.000Z","tags":["bash"],"toc":false,"description":"Nếu bạn muốn xem các câu lệnh bash được sử dụng nhiều nhất hãy gõ lệnh sau vào Terminal (Linux và MacOSX đều chạy): Đây là danh sách những câu lệnh được dùng nhiều nhất của mình (Linux Mint) Của bạn…","__filename":"cau-lenh-bash-duoc-ban-dung-nhieu-nhat.md","__url":"/cau-lenh-bash-duoc-ban-dung-nhieu-nhat/","__resourceUrl":"/cau-lenh-bash-duoc-ban-dung-nhieu-nhat/index.html","__dataUrl":"/cau-lenh-bash-duoc-ban-dung-nhieu-nhat/index.html.c017bcd1ac333472cea44a567ae78ea2.json"},{"layout":"Post","title":"Chuyển đổi Blog từ Wordpress sang Ghost","date":"2015-01-07T13:48:54.000Z","tags":["meta"],"toc":false,"description":"Hôm nay mình đã hoàn thành việc chuyển đổi và chính thức sử dụng Ghost cho Blog của mình Ghost : [http://ghost.org] Một số lí do mình sử dụng Ghost Trình soạn thảo Markdown thích hợp cho việc viết…","__filename":"chuyen-doi-blog-tu-wordpress-sang-ghost.md","__url":"/chuyen-doi-blog-tu-wordpress-sang-ghost/","__resourceUrl":"/chuyen-doi-blog-tu-wordpress-sang-ghost/index.html","__dataUrl":"/chuyen-doi-blog-tu-wordpress-sang-ghost/index.html.4f9268725c99fef0c1450d2b7be38c3d.json"},{"layout":"Post","title":"Database Seeder - Tạo dummy data - Larask Gist","date":"2015-03-13T17:00:00.000Z","description":"[Series] Larask Gist - Thiết lập Database Seeder , chuẩn bị dummy data","tags":["laravel"],"__filename":"database-seeder-larask-gist.md","__url":"/database-seeder-larask-gist/","__resourceUrl":"/database-seeder-larask-gist/index.html","__dataUrl":"/database-seeder-larask-gist/index.html.cfe20e1d10b58542cca474f560b14c52.json"},{"layout":"Post","title":"Detour - Giới thiệu và sử dụng UUID","date":"2015-03-13T10:00:00.000Z","description":"[Series] Larask Gist - Sử dụng UUID để bảo vệ những thông tin nhạy cảm của ứng dụng","tags":["laravel"],"__filename":"detour-gioi-thieu-va-su-dung-uuid-voi-larask-gist.md","__url":"/detour-gioi-thieu-va-su-dung-uuid-voi-larask-gist/","__resourceUrl":"/detour-gioi-thieu-va-su-dung-uuid-voi-larask-gist/index.html","__dataUrl":"/detour-gioi-thieu-va-su-dung-uuid-voi-larask-gist/index.html.5895afff7f53f7512e845dcd1bd8e723.json"},{"layout":"Post","title":"DigitalOcean : Cách đăng kí VPS và sử dụng promo code","date":"2014-11-17T10:12:01.000Z","tags":["vps"],"description":"VPS là gì ? VPS (Vitrual Private Servers) là 1 server ảo có khả năng chạy 24/24 các chương trình mà bạn thiết lập. Bạn có thể chạy các chương trình để kiếm tiền hoặc đặt một website/blog lên đó khi…","__filename":"digitalocean-dang-ki-vps-va-coupon.md","__url":"/digitalocean-dang-ki-vps-va-coupon/","__resourceUrl":"/digitalocean-dang-ki-vps-va-coupon/index.html","__dataUrl":"/digitalocean-dang-ki-vps-va-coupon/index.html.d8001da3c44f080e3095d6edecb12108.json"},{"layout":"Post","title":"@each với Laravel Blade","date":"2015-03-16T10:00:00.000Z","description":"Sử dụng @each trong Laravel Blade để giúp template gọn gàng hơn","tags":["laravel"],"toc":false,"__filename":"each-voi-laravel-blade.md","__url":"/each-voi-laravel-blade/","__resourceUrl":"/each-voi-laravel-blade/index.html","__dataUrl":"/each-voi-laravel-blade/index.html.334aa7949d1596670563583647e9f20d.json"},{"layout":"Post","title":"Tổng quan ES6 qua 350 điểm","date":"2016-02-21T20:20:00.000Z","tags":["js"],"draft":true,"translate":{"url":"https://ponyfoo.com/articles/es6","author":"Pony Foo"},"description":"Giới thiệu ES6, còn được biết với tên Harmony, es-next, ES2015 là bản mô tả mới nhất của Javascript Bản mô tả ES6 hoàn thành vào tháng 6 năm 2015 (vì vậy mới gọi là ES2015) Các bản mô tả tiếp theo…","__filename":"es6.md","__url":"/es6/","__resourceUrl":"/es6/index.html","__dataUrl":"/es6/index.html.dec750c93567f29d43f8c0049af36cf4.json"},{"layout":"Post","title":"Facebook Comment Responsive","date":"2015-01-07T10:16:10.000Z","tags":["css"],"description":"Mặc định thì Facebook Comment không hỗ trợ responsive, tuy nhiên với 1 ít hack với CSS và HTML5, Facebook Comment ngay lập tức sẽ hỗ trợ responsive. Lấy code Facebook Comments Truy cập vào Facebook…","__filename":"facebook-comment-responsive.md","__url":"/facebook-comment-responsive/","__resourceUrl":"/facebook-comment-responsive/index.html","__dataUrl":"/facebook-comment-responsive/index.html.053760a914ffe592f76a5e5942cb4435.json"},{"layout":"Post","title":"Free VPS 7 ngày 2GB RAM Windows Server từ CloudSigma","date":"2014-11-24T21:46:11.000Z","tags":["vps"],"toc":false,"description":"Hiện tại CloudSigma đang có chương trình free trial VPS với các thông số như sau: 2GB RAM CPU 2GHz Bandwidth 5 GB (vừa đủ để anh em nhà mình chiến hitleap trong 1 tuần) Mình đã tạo cỡ 10 tài khoản…","__filename":"free-vps-7-ngay-2gb-ram-windows-server-cloudsigma.md","__url":"/free-vps-7-ngay-2gb-ram-windows-server-cloudsigma/","__resourceUrl":"/free-vps-7-ngay-2gb-ram-windows-server-cloudsigma/index.html","__dataUrl":"/free-vps-7-ngay-2gb-ram-windows-server-cloudsigma/index.html.8fad5c9424253a6b7c39e984eb973aeb.json"},{"layout":"Post","title":"Giới thiệu Discourse","date":"2014-12-01T17:53:10.000Z","tags":["discourse"],"description":"Discourse là gì? Discourse là một dự án mã nguồn mở để xây dựng một nền tảng thảo luận online có thể dùng với các mục đích sau : Danh sách gửi mail Một diễn đàn thảo luận Một chat room Mục tiêu…","__filename":"gioi-thieu-discourse.md","__url":"/gioi-thieu-discourse/","__resourceUrl":"/gioi-thieu-discourse/index.html","__dataUrl":"/gioi-thieu-discourse/index.html.5121bd075aed20f5c2d3cb2d49b80951.json"},{"layout":"Post","title":"Giới thiệu Series Discourse cơ bản","date":"2015-01-07T08:30:20.000Z","tags":["discourse"],"toc":false,"description":"Discourse là một dự án mã nguồn mở để xây dựng một nền tảng thảo luận online có thể dùng với các mục đích sau : Danh sách gửi mail Một diễn đàn thảo luận Một chat room Mục tiêu của Discourse là…","__filename":"gioi-thieu-series-discourse-co-ban.md","__url":"/gioi-thieu-series-discourse-co-ban/","__resourceUrl":"/gioi-thieu-series-discourse-co-ban/index.html","__dataUrl":"/gioi-thieu-series-discourse-co-ban/index.html.724ad7a069d81de59c1a32f09f7ef001.json"},{"layout":"Post","title":"Giới thiệu series Larask Gist","date":"2015-03-12T13:00:00.000Z","description":"[Series] Larask Gist - A Laravel 5 Github Clone","tags":["laravel"],"__filename":"gioi-thieu-series-larask-gist.md","__url":"/gioi-thieu-series-larask-gist/","__resourceUrl":"/gioi-thieu-series-larask-gist/index.html","__dataUrl":"/gioi-thieu-series-larask-gist/index.html.3ba8fd5403687bcf6b1c1bd32d7ff0d3.json"},{"layout":"Post","title":"Giới thiệu Series Laravel 4 cơ bản","date":"2015-01-04T14:46:23.000Z","tags":["laravel"],"description":"Giới thiệu Laravel Laravel là một Framework mã nguồn mở sử mô hình MVC (Model-View-Controller) mạnh mẽ giúp bạn có thể dễ dàng tạo ra các ứng dụng PHP từ đơn giản đến phức tạp nhất một các nhanh…","__filename":"gioi-thieu-series-laravel-4-co-ban.md","__url":"/gioi-thieu-series-laravel-4-co-ban/","__resourceUrl":"/gioi-thieu-series-laravel-4-co-ban/index.html","__dataUrl":"/gioi-thieu-series-laravel-4-co-ban/index.html.28e3cbc6713d18551ff5b7c76c707799.json"},{"layout":"Post","title":"iMacros Omnia3 cắm máy kiếm euro tự động","date":"2014-11-23T10:51:23.000Z","toc":false,"tags":["laravel"],"description":"Update Mình đã ngừng hỗ trợ cho Ommia3 vì nghi vấn scam * * * Ở post trước mình đã có giới thiệu sơ lược về Omnia3  sau 1 ngày nghiên cứu thì mình thấy là site này có rate rất cao nên mình đã viết…","__filename":"imacros-omnia3-cam-may-kiem-euro-tu-dong.md","__url":"/imacros-omnia3-cam-may-kiem-euro-tu-dong/","__resourceUrl":"/imacros-omnia3-cam-may-kiem-euro-tu-dong/index.html","__dataUrl":"/imacros-omnia3-cam-may-kiem-euro-tu-dong/index.html.57dc622ceb05750e18c525fff16b5366.json"},{"title":"Khoa Nguyen Blog","layout":"Homepage","description":"","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.91fc28acc75f8be50d02def43fbf87e6.json"},{"layout":"Post","title":"json ⊄ js","date":"2016-02-19T23:22:00.000Z","tags":["js","json"],"translate":{"url":"https://medium.com/joys-of-javascript/json-js-42a28471221d#.m23ozaapw","author":"Dan Pupius"},"description":"Mọi người thường nói rằng JSON là một phần nhỏ (subset) của Javascript. Vấn đề là nó không phải như vậy. Dựa vào spec của JSON, một chuỗi có thể chứa bất cứ kí tự unicode nào ngoại trừ \" hoặc / hoặc…","__filename":"json-js.md","__url":"/json-js/","__resourceUrl":"/json-js/index.html","__dataUrl":"/json-js/index.html.458c2f731d5aa41c6fd9f8c8a92f19c7.json"},{"layout":"Post","title":"Kiếm tiền bằng cách rút gọn và chia sẽ link với Oni.vi (10.000 VND/ 1000 view)","date":"2014-11-23T11:50:29.000Z","tags":["mmo"],"description":"Update 12/01/2015 Oni.vn hiện tại đã dừng hoạt động * * * TƯNG BỪNG KHAI TRƯƠNG NHẬN QUÀ HẤP DẪN \\[​IMG] NHẬN NGAY 10.000 VND CHO MỖI 1000 LƯỢT XEM LINK (1 VIEW = 10 VND) \\[​IMG] \\[​IMG]   HỆ…","__filename":"kiem-tien-bang-cach-rut-gon-va-chia-se-link-voi-oni-vn.md","__url":"/kiem-tien-bang-cach-rut-gon-va-chia-se-link-voi-oni-vn/","__resourceUrl":"/kiem-tien-bang-cach-rut-gon-va-chia-se-link-voi-oni-vn/index.html","__dataUrl":"/kiem-tien-bang-cach-rut-gon-va-chia-se-link-voi-oni-vn/index.html.7f4fc175073fad5759d1ed0fbbcb20ea.json"},{"layout":"Post","title":"Laragon - Cài đặt Laravel trong 1 phút","date":"2015-03-11T20:00:00.000Z","description":"Hướng dẫn cài đặt Laragon - Laravel 5/4.2 trong một phút","tags":["laravel"],"__filename":"laragon-cai-dat-laravel-trong-mot-phut.md","__url":"/laragon-cai-dat-laravel-trong-mot-phut/","__resourceUrl":"/laragon-cai-dat-laravel-trong-mot-phut/index.html","__dataUrl":"/laragon-cai-dat-laravel-trong-mot-phut/index.html.a6117934124cb2dc0f470f032b00c077.json"},{"layout":"Post","title":"Cài đặt và thiết lập cơ bản cho Larask Gist","date":"2015-03-12T18:00:00.000Z","description":"Hướng dẫn cài đặt Laravel 5 và thiết lập cơ bản cho ứng dụng","tags":["laravel"],"__filename":"larask-gist-cai-dat-va-cau-hinh-co-ban.md","__url":"/larask-gist-cai-dat-va-cau-hinh-co-ban/","__resourceUrl":"/larask-gist-cai-dat-va-cau-hinh-co-ban/index.html","__dataUrl":"/larask-gist-cai-dat-va-cau-hinh-co-ban/index.html.81560fa67ebffae0cab064aef45f3118.json"},{"layout":"Post","title":"Migration và Model trong Laravel 5 - Larask Gist","date":"2015-03-12T19:00:00.000Z","description":"Hướng dẫn tạo và sử dụng migration trong Laravel 5 - Series Larask Gist","tags":["laravel"],"__filename":"model-va-migration-trong-laravel-5-gist.md","__url":"/model-va-migration-trong-laravel-5-gist/","__resourceUrl":"/model-va-migration-trong-laravel-5-gist/index.html","__dataUrl":"/model-va-migration-trong-laravel-5-gist/index.html.b5c7e58d4374950428dcd9164c421029.json"},{"layout":"Post","title":"Omnia3: Xem video, upload video kiếm tiền","date":"2014-11-22T11:38:32.000Z","tag":["mmo"],"description":"Omina3 là 1 site mới khai trương và còn trong giai đoạn beta cách thức hoạt động site này rất đơn giản. Chỉ cần bạn xem video (tức là xem quảng cáo của nó) thì các bạn sẽ được tiền. Đơn vị tiền tệ sử…","__filename":"omnia3.md","__url":"/omnia3/","__resourceUrl":"/omnia3/index.html","__dataUrl":"/omnia3/index.html.6f5d3f495d4e78960b8ed32765f079b7.json"},{"layout":"Post","title":"PaidVerts - Cuộc cách mạng của Paid to click","date":"2014-11-15T21:44:16.000Z","tags":["mmo"],"description":"Thời gian gần đây, dân chơi MMO đang nóng lên với dịch vụ mới là PaidVerts, dịch vụ được mệnh danh là Cuộc cách mạng của Paid to click chúng ta hãy cùng tìm hiểu về PaidVerts và cách đầu tư để nhanh…","__filename":"paidverts-ptc.md","__url":"/paidverts-ptc/","__resourceUrl":"/paidverts-ptc/index.html","__dataUrl":"/paidverts-ptc/index.html.4fb796a79f4e43bd53650c27a612cfc2.json"},{"layout":"Post","title":"Quản lí các thư viện PHP với Composer","date":"2015-01-03T13:09:22.000Z","tags":["php","composer"],"description":"Update 26/01/2016: Các bạn có thể dùng prestissimo để tăng tốc độ cài đặt cho Composer (Parallel Composer) Gõ dòng lệnh này vào: credit: @VuNhatMinh * * * Composer là gì? Vài năm trước, nếu bạn…","__filename":"quan-li-cac-thu-vien-php-voi-composer.md","__url":"/quan-li-cac-thu-vien-php-voi-composer/","__resourceUrl":"/quan-li-cac-thu-vien-php-voi-composer/index.html","__dataUrl":"/quan-li-cac-thu-vien-php-voi-composer/index.html.89ab8ae278209423f1109c8196ca9a92.json"},{"layout":"Post","title":"React.Component với React.createClass","date":"2016-02-19T00:39:00.000Z","tags":["reactjs"],"translate":{"url":"http://reactjsnews.com/composing-components/","author":"Naman Goel & Zach Silveira"},"description":"Giới thiệu React hỗ trợ 2 cách để tạo Component. Bạn có thể kế thừa từ class React.Component hoặc là dùng cú pháp cũ React.createClass đã có từ khi React ra đời. Có lí do nào cụ thể để dùng một cú…","__filename":"react-component-voi-react-create-class.md","__url":"/react-component-voi-react-create-class/","__resourceUrl":"/react-component-voi-react-create-class/index.html","__dataUrl":"/react-component-voi-react-create-class/index.html.b4647d3db42f8ac1e4a7950ad7bfadbf.json"},{"layout":"Post","title":"React how to","date":"2016-02-20T10:00:00.000Z","tags":["reactjs"],"description":"From react-howto by @petehunt Vietnamese translated by @petehouston react-howto Nếu bạn mới làm quen với React (hoặc phần front-end nói chung) thì bạn sẽ thấy hệ sinh thái tương đối khó hiểu. Có…","__filename":"react-howto.md","__url":"/react-howto/","__resourceUrl":"/react-howto/index.html","__dataUrl":"/react-howto/index.html.98e5c90915d8e3c8f22f6c9feb1353db.json"},{"layout":"Post","title":"RunAbove : 6 tháng VPS 2GB RAM Windows miễn phí","date":"2014-11-17T17:38:02.000Z","tags":["vps"],"description":"Giới thiệu RunAbove RunAbove là CloudVPS sở hữu bởi OVH. Fact: OVH là nhà cung cấp hosting chất lượng đến từ Pháp. Giá VPS của RunAbove rất cạnh tranh, gói thấp nhất với 2GB RAM và CPU 1 core chỉ…","__filename":"runabove-6-thang-vps-windows-mien-phi.md","__url":"/runabove-6-thang-vps-windows-mien-phi/","__resourceUrl":"/runabove-6-thang-vps-windows-mien-phi/index.html","__dataUrl":"/runabove-6-thang-vps-windows-mien-phi/index.html.a290b016b58b0588c8303c6f6b0192a5.json"},{"layout":"Post","title":"Tạo logo Slack động với CSS3","date":"2016-02-02T19:51:00.000Z","image":"/images/2016/slack-logo/slack-featured.png","tags":["css"],"draft":true,"description":"Demo Slack & The Logo Slack là một cái tên khá nổi bây giờ. Slack giúp cho việc giao tiếp giữa các thành viên trong nhóm trở nên dễ dàng hơn. Mình chọn Slack logo để viết bài vì Slack logo được dùng…","__filename":"slack-logo-voi-css3.md","__url":"/slack-logo-voi-css3/","__resourceUrl":"/slack-logo-voi-css3/index.html","__dataUrl":"/slack-logo-voi-css3/index.html.d052b597bc831b4969be1e31342134e3.json"},{"layout":"Post","title":"npm: Tăng tốc và sử dụng offline","date":"2016-04-12T17:00:00.000Z","route":"tang-toc-npm","tags":["javascript"],"toc":false,"description":"Chắc chắn là ai đã từng làm việc với npm thì đều biết một điều rằng npm nó siêu chậm. Vì vậy mình hay hạn chế chạy npm install đến mức tối thiểu và thường không nhận được patch update, ... cũng như…","__filename":"tang-toc-npm/index.md","__url":"/tang-toc-npm/","__resourceUrl":"/tang-toc-npm/index.html","__dataUrl":"/tang-toc-npm/index.html.a6d63a013f3d0e26c2aca3c8d3b47ef2.json"},{"layout":"Post","title":"Tạo menu cho Discourse","date":"2015-01-09T00:10:59.000Z","tags":["discourse","css"],"toc":false,"description":"Giới thiệu Có nhiều bạn hỏi mình về cái menu Discourse của mình. Hôm nay mình sẽ chia sẽ code với các bạn. Menu sẽ tự động ản khi bạn trượt xuống nên yên tâm là sẽ không tốn quá nhiều diện tích. Demo…","__filename":"tao-menu-cho-discourse.md","__url":"/tao-menu-cho-discourse/","__resourceUrl":"/tao-menu-cho-discourse/index.html","__dataUrl":"/tao-menu-cho-discourse/index.html.d87f7d1052bdcb67cea62957a074a822.json"},{"layout":"Post","title":"Tắt plugin Wordpress khi không vào được Bảng điều khiển","date":"2014-11-16T14:25:54.000Z","tags":["wordpress"],"description":"Hôm qua mình có nghịch với mấy cái plugin WordPress và kết quả là không truy cập vào Bảng điểu khiển (Admin Dashboard) được nữa. Nên chẳng thể nào tắt plugin ấy đi được. Sau một hồi tìm kiếm, mình tìm…","__filename":"tat-plugin-wordpress-thu-cong.md","__url":"/tat-plugin-wordpress-thu-cong/","__resourceUrl":"/tat-plugin-wordpress-thu-cong/index.html","__dataUrl":"/tat-plugin-wordpress-thu-cong/index.html.7f681cb2cb61ca522051720f8a982d1e.json"},{"layout":"Post","title":"Các thuật ngữ MMO thông dụng nhất","date":"2014-11-16T01:27:07.000Z","tags":["mmo"],"description":"Nếu bạn mới bước chân vào việc kiếm tiền online thì chắc hẳn giữa 1 rừng thuật ngữ MMO sẽ làm bạn ngao ngán. Hy vọng bài viết này sẽ giúp bạn phần nào nắm bắt được MMO và tự tin triển khai kế hoạc của…","__filename":"thuat-ngu-mmo.md","__url":"/thuat-ngu-mmo/","__resourceUrl":"/thuat-ngu-mmo/index.html","__dataUrl":"/thuat-ngu-mmo/index.html.608e36b9fd73a865f2554f0eb00f4fa4.json"},{"layout":"Post","title":"Tìm hiểu định dạng MDict (MDD/MDX)","date":"2016-04-05T07:00:00.000Z","route":"tim-hieu-dinh-dang-mdict","tags":["algorithm"],"toc":false,"description":"MDict là một phần mềm đọc tự điển cho định dạng MDD và MDX (cũng do MDict tạo ra) với khả năng tra những danh mục từ điển hàng nghìn từ một cách siêu nhanh và đã rất nổi tiếng từ thời Window Mobile…","__filename":"tim-hieu-dinh-dang-mdict/index.md","__url":"/tim-hieu-dinh-dang-mdict/","__resourceUrl":"/tim-hieu-dinh-dang-mdict/index.html","__dataUrl":"/tim-hieu-dinh-dang-mdict/index.html.821a8fe080e52da8a4466503f2f1f218.json"},{"layout":"Post","title":"Mô hình MVC là gì?","date":"2015-01-04T19:58:21.000Z","tags":["mvc"],"description":"Nếu bạn là một lập trình viên, nhất là lập trình web, sẽ rất khó để bạn có thể xin được việc nếu không biết mô hình MVC. Trong post này mình sẽ trình bày đến các bạn mô hình MVC là gì theo cách hiểu…","__filename":"tim-hieu-mo-hinh-mvc-la-gi.md","__url":"/tim-hieu-mo-hinh-mvc-la-gi/","__resourceUrl":"/tim-hieu-mo-hinh-mvc-la-gi/index.html","__dataUrl":"/tim-hieu-mo-hinh-mvc-la-gi/index.html.06c61b881e3cfa4d7ebd68d4ca22def4.json"},{"layout":"Post","title":"[Video] RunAbove : Kích hoạt Remote Desktop","date":"2014-11-21T07:34:20.000Z","tags":["vps"],"description":"Mặc định thì trên 1 tài khoản mới và VPS mới tạo thì Remote Desktop không được kích. Điều này gây khó khăn cho một số bạn. Bài viết này mình sẽ hướng dẫn cách kích hoạt Remote Desktop trên RunAbove…","__filename":"video-runabove-kich-hoat-remote-desktop.md","__url":"/video-runabove-kich-hoat-remote-desktop/","__resourceUrl":"/video-runabove-kich-hoat-remote-desktop/index.html","__dataUrl":"/video-runabove-kich-hoat-remote-desktop/index.html.64ae06d3e2f23bc06493d2dec605de13.json"},{"layout":"Post","title":"Xóa tất cả table trong database MySQL","date":"2015-03-15T08:00:00.000Z","description":"MySQL Procedure giúp xóa nhanh tất cả table trong 1 database","tags":["mysql"],"toc":false,"__filename":"xoa-tat-ca-cac-table-mysql.md","__url":"/xoa-tat-ca-cac-table-mysql/","__resourceUrl":"/xoa-tat-ca-cac-table-mysql/index.html","__dataUrl":"/xoa-tat-ca-cac-table-mysql/index.html.1d5c817823da676285785c5e3d227071.json"}];window.__INITIAL_STATE__ = {"pages":{"/react-component-voi-react-create-class/":{"head":{"layout":"Post","title":"React.Component với React.createClass","date":"2016-02-19T00:39:00.000Z","tags":["reactjs"],"translate":{"url":"http://reactjsnews.com/composing-components/","author":"Naman Goel & Zach Silveira"},"description":"Giới thiệu React hỗ trợ 2 cách để tạo Component. Bạn có thể kế thừa từ class React.Component hoặc là dùng cú pháp cũ React.createClass đã có từ khi React ra đời. Có lí do nào cụ thể để dùng một cú…"},"body":"<h1 id=\"Gioi-thieu\"><a class=\"markdownIt-Anchor\" href=\"#Gioi-thieu\">#</a> Giới thiệu</h1>\n<p>React hỗ trợ 2 cách để tạo Component.\nBạn có thể kế thừa từ class <code>React.Component</code> hoặc là\ndùng cú pháp cũ <code>React.createClass</code> đã có từ khi React ra đời.\nCó lí do nào cụ thể để dùng một cú pháp thay vì cú pháp còn lại?</p>\n<p>Thực tế, nó hoàn toàn phụ thuộc vào bạn.</p>\n<p>Theo quan điểm của mình thì nó chẳng có khác biệt gì lớn.\nTrong hầu hết mọi trường hợp, sự khác biệt giữa <code>React.createClass</code>\nvà <code>class X extends React.Component</code> chỉ là cú pháp. Nếu bạn\nkhông dùng mixin hoặc decorator thường xuyên thì chỉ việc dùng cấu\ntrúc nào bạn thích nhất.</p>\n<p>Ngoài ra, có vài lí do thực sự buộc bạn phải chọn một cú pháp\nnhất định.</p>\n<p>Có vài tính năng bạn sẽ không thể sử dụng khi dùng ES6 class như là\nmixin, hàm autoBound và <code>this.isMounted</code>. ES6 class cũng có nghĩa là\nbạn sẽ phải phụ thuộc vào một công cụ build (như Babel). Nếu bạn\nkhông dùng JSX, và đã viết ES5 code không cần chuyển đổi, đây thực\nsự là một lí do quan trọng.</p>\n<p>Nhưng trước khi nêu ra những ưu điểm và nhược điểm,\ncần phải nói rõ rằng dùng ES6 class thay vì <code>React.createClass</code>\nKHÔNG làm code của bạn mất đi, hoặc có thêm tính hướng đối tượng\n(Object oriented). Nó chỉ là sự khác biệt về cú pháp, nó có ít tính\nnăng hơn, nhưng điều quan trọng là bạn đang dùng\n<code>constructor pattern</code> thay vì <code>factory pattern</code>. Vì vậy, nếu bạn muốn\ncode của bạn rõ ràng hơn, đây chính là một điều không thể bàn cãi đối với bạn.</p>\n<p>Mặt khác, ES6 class giúp bạn có thể dễ dàng thừa kế (inheritane).\nNhưng mình khuyên là đừng làm như vậy, hãy bỏ ngay ý tưởng dùng\nES6 class chỉ để thực hiện một chuỗi thừa kế dài, hãy dùng\n<code>React.createClass</code> và kèm với mixin.</p>\n<h1 id=\"Li-do-de-dung-ReactcreateClass\"><a class=\"markdownIt-Anchor\" href=\"#Li-do-de-dung-ReactcreateClass\">#</a> Lí do để dùng <code>React.createClass</code></h1>\n<h2 id=\"Toi-thich-ham-auto-binding\"><a class=\"markdownIt-Anchor\" href=\"#Toi-thich-ham-auto-binding\">#</a> “Tôi thích hàm auto-binding”</h2>\n<p>Đây là một lí do chính đáng, tuy nhiên bạn có thể autobind với ES6 class\n<a href=\"https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding\">(bài viết từ React)</a></p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span> () {\n    <span class=\"hljs-keyword\">super</span>();\n    <span class=\"hljs-keyword\">this</span>.tick = <span class=\"hljs-keyword\">this</span>.tick.bind(<span class=\"hljs-keyword\">this</span>);\n  }\n  tick () {\n    ...\n  }\n  ...\n}</code></pre>\n<p>Sử dụng Babel <code>stage: 0</code> bạn có thể viết class như thế này:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  tick = () =&gt; {\n    ...\n  }\n  ...\n}</code></pre>\n<p>Nếu bạn không thích <code>stage: 0</code>, có lựa chọn khác dành cho bạn.\nVí dụ như là dùng\n<a href=\"https://github.com/andreypopp/autobind-decorator\">autobind decorator</a></p>\n<p>Decorator cũng là <code>stage: 0</code> nhưng bạn thực sự không cần stage 0\ndể dùng <code>autobind decorator</code></p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  tick () {\n    ...\n  }\n  ...\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> autobind(Counter)</code></pre>\n<h2 id=\"Toi-thich-mixins\"><a class=\"markdownIt-Anchor\" href=\"#Toi-thich-mixins\">#</a> “Tôi thích mixins”</h2>\n<p>Đây gần như là lí do chính mọi người vẫn sử dụng <code>React.createClass</code>.\nCó rất nhiều code React vẫn còn dựa trên mixins. Tuy nhiên, bạn có thể dùng\n<a href=\"https://www.npmjs.com/package/react-mixin\">React-mixin</a>\nđể có mixin với ES6 class</p>\n<h2 id=\"thisisMounted\"><a class=\"markdownIt-Anchor\" href=\"#thisisMounted\">#</a> <code>this.isMounted</code></h2>\n<p>Bạn chẳng bao giờ sử dụng <code>this.isMounted</code> cả, và khi bạn cần, nó\ncũng rất dễ để thêm vào.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  componentDidMount () {\n    <span class=\"hljs-keyword\">this</span>.isMounted = <span class=\"hljs-literal\">true</span>\n  }\n  tick () {\n    ...\n  }\n  ...\n}</code></pre>\n<p>Bản thân mình chẳng bao giờ sử dụng tính năng này.</p>\n<h1 id=\"Li-do-de-chuyen-sang-dung-cu-phap-ES6\"><a class=\"markdownIt-Anchor\" href=\"#Li-do-de-chuyen-sang-dung-cu-phap-ES6\">#</a> Lí do để chuyển sang dùng cú pháp ES6</h1>\n<h2 id=\"Autobinding\"><a class=\"markdownIt-Anchor\" href=\"#Autobinding\">#</a> Autobinding?</h2>\n<p>Vấn đề về <code>context</code> trong Javascript khá là nhức nhối. Việc\ntự động <code>autobinding</code> được <code>React.createClass</code> thực hiện đôi\nkhi gây khó hiểu cho những bạn mới làm quên, và sự rắc rối của\nbinding có thể làm bạn khó hiểu trong nhiều tháng liền.\nVới ES6 class, bạn phải tự thực hiện binding. Điều này giúp\ncode của bạn rõ ràng hơn, ít “thần kì” hơn. Và sẽ giúp cho các\nlập trình viên mới tiếp xúc với React biết thực “chuyện gì đang xảy ra”. Bằng sự trợ giúp của Babel với các tính năng của\nES6/7, binding thủ công không còn là một vấn đề lớn.</p>\n<h2 id=\"Bo-qua-Mixins-hay-dung-Higher-Order-Components\"><a class=\"markdownIt-Anchor\" href=\"#Bo-qua-Mixins-hay-dung-Higher-Order-Components\">#</a> Bỏ qua Mixins, hãy dùng Higher-Order-Components</h2>\n<p>Nếu bạn có xem qua bất cứ thảo luận nào về ES6 class, bạn sẽ\nthấy mọi người nói bạn dùng <strong>kết hợp</strong> (composition) thay cho <strong>thừa kế</strong>.\nBạn có thể đã thấy meme này</p>\n<p><img src=\"/images/2016/react-component-vs-create-class/compose-all-the-things.png\" alt=\"compose all the things\"></p>\n<p>Sự thật thì thừa kế là một cách tồi tệ để viết code. Nó đến lỗi, lỗi thời và khó hiểu. Nó buộc bạn phải viết theo một\ncách giống nhau. Mixins chắc chắn là một giải phải tốt hơn\n(thừa kế), nhưng các lập trình viện thừa lạm dụng chúng để\nlàm những thứ có thể dễ dàng đạt được với kết hợp. Và điều\nquan trọng nhất là Higher-Order-Component có thể dùng với cả\nhai cách tạo Component và cả pure functions.</p>\n<blockquote>\n<p>Đọc thêm\n<a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.ki6u85yvc\">Mixins are dead long live higher oder components</a></p>\n</blockquote>\n<h2 id=\"Khong-con-code-thua-No-Cruft\"><a class=\"markdownIt-Anchor\" href=\"#Khong-con-code-thua-No-Cruft\">#</a> Không còn code thừa (No Cruft)</h2>\n<p>Loại bỏ những tính năng hiếm khi sử dụng như <code>this.isMounted</code>\nsẽ giúp React nhẹ hơn và linh hoạt hơn. Theo thời gian, điều\nnày sẽ giúp React nhanh hơn. Mình biết là tất cả chúng ta đều\nyêu React, nhưng chúng ta cũng muốn có tốc độ phải không nào ?</p>\n<h2 id=\"FlowTypes\"><a class=\"markdownIt-Anchor\" href=\"#FlowTypes\">#</a> FlowTypes</h2>\n<p>Đây là điều mà mình thích nhất. Trong một thời gian dài, mình\nđã cố tình bỏ qua Typescript và Flow, nhưng sau khi mất nguyên\nmột ngày vì gõ sai tên <code>sự kiện</code> (event), mình bắt đầu dùng\nFlow và chưa bao giờ nhìn lại. Flow giúp bạn thực hiện chuyển\nđổi một cách chậm chạp, theo từng file. Và đừng xem thường, nó\nsẽ giúp bạn tìm ra hàng tá lỗi mà bạn chưa từng biết đến sự\ntồn tại.</p>\n<p>Nhưng điều này giúp ích gì khi dùng ES6 class ?\nFlowtype và Typescript sẽ dễ dàng hơn nếu bạn đang dùng ES6 class.</p>\n<p>Đây là một ví dụ:</p>\n<p>ES6 class</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">X</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  someProp: string | number;\n  state: SomeType;\n  props: SomeType;\n  ...\n}</code></pre>\n<p>React.createClass</p>\n<pre><code class=\"language-js\">React.createClass({\n  someProp: (<span class=\"hljs-number\">0</span>: string | number),\n  ...\n})</code></pre>\n<p>Và sự thật là bạn không thể định kiểu (type) cho props và state với\nflow khi dùng React.createClass. Thay và đó, Flow phụ thuộc\nvào hàng tá code để có thể xác định kiểu bằng việc đọc <code>propTypes</code>.\nThực tế thì nó chưa bao giờ làm tốt như vậy. Và đừng có nghĩ đến việc\nkiểm tra kiểu (type checking) với state. Nó đơn giản là không thể.</p>\n<h1 id=\"Ket-luan\"><a class=\"markdownIt-Anchor\" href=\"#Ket-luan\">#</a> Kết luận</h1>\n<p>Cả 2 kiểu tạo component như trên đều sẽ không biến mất trong\ntương lại gần. Nếu ES6 class trở thành cách mà mọi người chọn\nthay vì <code>createClass</code>, Javascript cần nhiều hơn là một <code>sugar syntax</code>\n(tạm dịch là cú pháp thân thuộc), nó cần <code>class</code> thực sự.\nMình chọn viết component bằng ES6 class vì nó nhìn gọn hơn,\nkhông cần đặt dấu phẩy và sau mỗi hàm, và những điều hạn chế\nkể trên với cú pháp này không ảnh hướng nhiều đến mình.</p>\n","rawBody":"\n# Giới thiệu\n\nReact hỗ trợ 2 cách để tạo Component.\nBạn có thể kế thừa từ class `React.Component` hoặc là\ndùng cú pháp cũ `React.createClass` đã có từ khi React ra đời.\nCó lí do nào cụ thể để dùng một cú pháp thay vì cú pháp còn lại?\n\nThực tế, nó hoàn toàn phụ thuộc vào bạn.\n\nTheo quan điểm của mình thì nó chẳng có khác biệt gì lớn.\nTrong hầu hết mọi trường hợp, sự khác biệt giữa `React.createClass`\nvà `class X extends React.Component` chỉ là cú pháp. Nếu bạn\nkhông dùng mixin hoặc decorator thường xuyên thì chỉ việc dùng cấu\ntrúc nào bạn thích nhất.\n\nNgoài ra, có vài lí do thực sự buộc bạn phải chọn một cú pháp\nnhất định.\n\nCó vài tính năng bạn sẽ không thể sử dụng khi dùng ES6 class như là\nmixin, hàm autoBound và `this.isMounted`. ES6 class cũng có nghĩa là\nbạn sẽ phải phụ thuộc vào một công cụ build (như Babel). Nếu bạn\nkhông dùng JSX, và đã viết ES5 code không cần chuyển đổi, đây thực\nsự là một lí do quan trọng.\n\nNhưng trước khi nêu ra những ưu điểm và nhược điểm,\ncần phải nói rõ rằng dùng ES6 class thay vì `React.createClass`\nKHÔNG làm code của bạn mất đi, hoặc có thêm tính hướng đối tượng\n(Object oriented). Nó chỉ là sự khác biệt về cú pháp, nó có ít tính\nnăng hơn, nhưng điều quan trọng là bạn đang dùng\n`constructor pattern` thay vì `factory pattern`. Vì vậy, nếu bạn muốn\ncode của bạn rõ ràng hơn, đây chính là một điều không thể bàn cãi đối với bạn.\n\nMặt khác, ES6 class giúp bạn có thể dễ dàng thừa kế (inheritane).\nNhưng mình khuyên là đừng làm như vậy, hãy bỏ ngay ý tưởng dùng\nES6 class chỉ để thực hiện một chuỗi thừa kế dài, hãy dùng\n`React.createClass` và kèm với mixin.\n\n# Lí do để dùng `React.createClass`\n\n## \"Tôi thích hàm auto-binding\"\n\nĐây là một lí do chính đáng, tuy nhiên bạn có thể autobind với ES6 class\n[(bài viết từ React)](https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding)\n\n```js\nclass Counter extends React.Component {\n  constructor () {\n    super();\n    this.tick = this.tick.bind(this);\n  }\n  tick () {\n    ...\n  }\n  ...\n}\n```\n\nSử dụng Babel `stage: 0` bạn có thể viết class như thế này:\n\n```js\nclass Counter extends React.Component {\n  tick = () => {\n    ...\n  }\n  ...\n}\n```\n\nNếu bạn không thích `stage: 0`, có lựa chọn khác dành cho bạn.\nVí dụ như là dùng\n[autobind decorator](https://github.com/andreypopp/autobind-decorator)\n\nDecorator cũng là `stage: 0` nhưng bạn thực sự không cần stage 0\ndể dùng `autobind decorator`\n\n```js\nclass Counter extends React.Component {\n  tick () {\n    ...\n  }\n  ...\n}\n\nexport default autobind(Counter)\n```\n\n## \"Tôi thích mixins\"\n\nĐây gần như là lí do chính mọi người vẫn sử dụng `React.createClass`.\nCó rất nhiều code React vẫn còn dựa trên mixins. Tuy nhiên, bạn có thể dùng\n[React-mixin](https://www.npmjs.com/package/react-mixin)\nđể có mixin với ES6 class\n\n## `this.isMounted`\n\nBạn chẳng bao giờ sử dụng `this.isMounted` cả, và khi bạn cần, nó\ncũng rất dễ để thêm vào.\n\n```js\nclass Counter extends React.Component {\n  componentDidMount () {\n    this.isMounted = true\n  }\n  tick () {\n    ...\n  }\n  ...\n}\n```\n\nBản thân mình chẳng bao giờ sử dụng tính năng này.\n\n# Lí do để chuyển sang dùng cú pháp ES6\n\n## Autobinding?\n\nVấn đề về `context` trong Javascript khá là nhức nhối. Việc\ntự động `autobinding` được `React.createClass` thực hiện đôi\nkhi gây khó hiểu cho những bạn mới làm quên, và sự rắc rối của\nbinding có thể làm bạn khó hiểu trong nhiều tháng liền.\nVới ES6 class, bạn phải tự thực hiện binding. Điều này giúp\ncode của bạn rõ ràng hơn, ít \"thần kì\" hơn. Và sẽ giúp cho các\nlập trình viên mới tiếp xúc với React biết thực \"chuyện gì đang xảy ra\". Bằng sự trợ giúp của Babel với các tính năng của\nES6/7, binding thủ công không còn là một vấn đề lớn.\n\n## Bỏ qua Mixins, hãy dùng Higher-Order-Components\n\nNếu bạn có xem qua bất cứ thảo luận nào về ES6 class, bạn sẽ\nthấy mọi người nói bạn dùng **kết hợp** (composition) thay cho **thừa kế**.\nBạn có thể đã thấy meme này\n\n![compose all the things](/images/2016/react-component-vs-create-class/compose-all-the-things.png)\n\nSự thật thì thừa kế là một cách tồi tệ để viết code. Nó đến lỗi, lỗi thời và khó hiểu. Nó buộc bạn phải viết theo một\ncách giống nhau. Mixins chắc chắn là một giải phải tốt hơn\n(thừa kế), nhưng các lập trình viện thừa lạm dụng chúng để\nlàm những thứ có thể dễ dàng đạt được với kết hợp. Và điều\nquan trọng nhất là Higher-Order-Component có thể dùng với cả\nhai cách tạo Component và cả pure functions.\n\n> Đọc thêm\n> [Mixins are dead long live higher oder components](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.ki6u85yvc)\n\n## Không còn code thừa (No Cruft)\n\nLoại bỏ những tính năng hiếm khi sử dụng như `this.isMounted`\nsẽ giúp React nhẹ hơn và linh hoạt hơn. Theo thời gian, điều\nnày sẽ giúp React nhanh hơn. Mình biết là tất cả chúng ta đều\nyêu React, nhưng chúng ta cũng muốn có tốc độ phải không nào ?\n\n## FlowTypes\n\nĐây là điều mà mình thích nhất. Trong một thời gian dài, mình\nđã cố tình bỏ qua Typescript và Flow, nhưng sau khi mất nguyên\nmột ngày vì gõ sai tên `sự kiện` (event), mình bắt đầu dùng\nFlow và chưa bao giờ nhìn lại. Flow giúp bạn thực hiện chuyển\nđổi một cách chậm chạp, theo từng file. Và đừng xem thường, nó\nsẽ giúp bạn tìm ra hàng tá lỗi mà bạn chưa từng biết đến sự\ntồn tại.\n\nNhưng điều này giúp ích gì khi dùng ES6 class ?\nFlowtype và Typescript sẽ dễ dàng hơn nếu bạn đang dùng ES6 class.\n\nĐây là một ví dụ:\n\nES6 class\n\n```js\nclass X extends React.Component {\n  someProp: string | number;\n  state: SomeType;\n  props: SomeType;\n  ...\n}\n```\n\nReact.createClass\n\n```js\nReact.createClass({\n  someProp: (0: string | number),\n  ...\n})\n```\n\nVà sự thật là bạn không thể định kiểu (type) cho props và state với\nflow khi dùng React.createClass. Thay và đó, Flow phụ thuộc\nvào hàng tá code để có thể xác định kiểu bằng việc đọc `propTypes`.\nThực tế thì nó chưa bao giờ làm tốt như vậy. Và đừng có nghĩ đến việc\nkiểm tra kiểu (type checking) với state. Nó đơn giản là không thể.\n\n# Kết luận\n\nCả 2 kiểu tạo component như trên đều sẽ không biến mất trong\ntương lại gần. Nếu ES6 class trở thành cách mà mọi người chọn\nthay vì `createClass`, Javascript cần nhiều hơn là một `sugar syntax`\n(tạm dịch là cú pháp thân thuộc), nó cần `class` thực sự.\nMình chọn viết component bằng ES6 class vì nó nhìn gọn hơn,\nkhông cần đặt dấu phẩy và sau mỗi hàm, và những điều hạn chế\nkể trên với cú pháp này không ảnh hướng nhiều đến mình.\n","raw":"---\nlayout: Post\ntitle: \"React.Component với React.createClass\"\ndate: 2016-02-19 00:39:00\ntags: [reactjs]\ntranslate:\n  url: http://reactjsnews.com/composing-components/\n  author: \"Naman Goel & Zach Silveira\"\n---\n\n# Giới thiệu\n\nReact hỗ trợ 2 cách để tạo Component.\nBạn có thể kế thừa từ class `React.Component` hoặc là\ndùng cú pháp cũ `React.createClass` đã có từ khi React ra đời.\nCó lí do nào cụ thể để dùng một cú pháp thay vì cú pháp còn lại?\n\nThực tế, nó hoàn toàn phụ thuộc vào bạn.\n\nTheo quan điểm của mình thì nó chẳng có khác biệt gì lớn.\nTrong hầu hết mọi trường hợp, sự khác biệt giữa `React.createClass`\nvà `class X extends React.Component` chỉ là cú pháp. Nếu bạn\nkhông dùng mixin hoặc decorator thường xuyên thì chỉ việc dùng cấu\ntrúc nào bạn thích nhất.\n\nNgoài ra, có vài lí do thực sự buộc bạn phải chọn một cú pháp\nnhất định.\n\nCó vài tính năng bạn sẽ không thể sử dụng khi dùng ES6 class như là\nmixin, hàm autoBound và `this.isMounted`. ES6 class cũng có nghĩa là\nbạn sẽ phải phụ thuộc vào một công cụ build (như Babel). Nếu bạn\nkhông dùng JSX, và đã viết ES5 code không cần chuyển đổi, đây thực\nsự là một lí do quan trọng.\n\nNhưng trước khi nêu ra những ưu điểm và nhược điểm,\ncần phải nói rõ rằng dùng ES6 class thay vì `React.createClass`\nKHÔNG làm code của bạn mất đi, hoặc có thêm tính hướng đối tượng\n(Object oriented). Nó chỉ là sự khác biệt về cú pháp, nó có ít tính\nnăng hơn, nhưng điều quan trọng là bạn đang dùng\n`constructor pattern` thay vì `factory pattern`. Vì vậy, nếu bạn muốn\ncode của bạn rõ ràng hơn, đây chính là một điều không thể bàn cãi đối với bạn.\n\nMặt khác, ES6 class giúp bạn có thể dễ dàng thừa kế (inheritane).\nNhưng mình khuyên là đừng làm như vậy, hãy bỏ ngay ý tưởng dùng\nES6 class chỉ để thực hiện một chuỗi thừa kế dài, hãy dùng\n`React.createClass` và kèm với mixin.\n\n# Lí do để dùng `React.createClass`\n\n## \"Tôi thích hàm auto-binding\"\n\nĐây là một lí do chính đáng, tuy nhiên bạn có thể autobind với ES6 class\n[(bài viết từ React)](https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding)\n\n```js\nclass Counter extends React.Component {\n  constructor () {\n    super();\n    this.tick = this.tick.bind(this);\n  }\n  tick () {\n    ...\n  }\n  ...\n}\n```\n\nSử dụng Babel `stage: 0` bạn có thể viết class như thế này:\n\n```js\nclass Counter extends React.Component {\n  tick = () => {\n    ...\n  }\n  ...\n}\n```\n\nNếu bạn không thích `stage: 0`, có lựa chọn khác dành cho bạn.\nVí dụ như là dùng\n[autobind decorator](https://github.com/andreypopp/autobind-decorator)\n\nDecorator cũng là `stage: 0` nhưng bạn thực sự không cần stage 0\ndể dùng `autobind decorator`\n\n```js\nclass Counter extends React.Component {\n  tick () {\n    ...\n  }\n  ...\n}\n\nexport default autobind(Counter)\n```\n\n## \"Tôi thích mixins\"\n\nĐây gần như là lí do chính mọi người vẫn sử dụng `React.createClass`.\nCó rất nhiều code React vẫn còn dựa trên mixins. Tuy nhiên, bạn có thể dùng\n[React-mixin](https://www.npmjs.com/package/react-mixin)\nđể có mixin với ES6 class\n\n## `this.isMounted`\n\nBạn chẳng bao giờ sử dụng `this.isMounted` cả, và khi bạn cần, nó\ncũng rất dễ để thêm vào.\n\n```js\nclass Counter extends React.Component {\n  componentDidMount () {\n    this.isMounted = true\n  }\n  tick () {\n    ...\n  }\n  ...\n}\n```\n\nBản thân mình chẳng bao giờ sử dụng tính năng này.\n\n# Lí do để chuyển sang dùng cú pháp ES6\n\n## Autobinding?\n\nVấn đề về `context` trong Javascript khá là nhức nhối. Việc\ntự động `autobinding` được `React.createClass` thực hiện đôi\nkhi gây khó hiểu cho những bạn mới làm quên, và sự rắc rối của\nbinding có thể làm bạn khó hiểu trong nhiều tháng liền.\nVới ES6 class, bạn phải tự thực hiện binding. Điều này giúp\ncode của bạn rõ ràng hơn, ít \"thần kì\" hơn. Và sẽ giúp cho các\nlập trình viên mới tiếp xúc với React biết thực \"chuyện gì đang xảy ra\". Bằng sự trợ giúp của Babel với các tính năng của\nES6/7, binding thủ công không còn là một vấn đề lớn.\n\n## Bỏ qua Mixins, hãy dùng Higher-Order-Components\n\nNếu bạn có xem qua bất cứ thảo luận nào về ES6 class, bạn sẽ\nthấy mọi người nói bạn dùng **kết hợp** (composition) thay cho **thừa kế**.\nBạn có thể đã thấy meme này\n\n![compose all the things](/images/2016/react-component-vs-create-class/compose-all-the-things.png)\n\nSự thật thì thừa kế là một cách tồi tệ để viết code. Nó đến lỗi, lỗi thời và khó hiểu. Nó buộc bạn phải viết theo một\ncách giống nhau. Mixins chắc chắn là một giải phải tốt hơn\n(thừa kế), nhưng các lập trình viện thừa lạm dụng chúng để\nlàm những thứ có thể dễ dàng đạt được với kết hợp. Và điều\nquan trọng nhất là Higher-Order-Component có thể dùng với cả\nhai cách tạo Component và cả pure functions.\n\n> Đọc thêm\n> [Mixins are dead long live higher oder components](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.ki6u85yvc)\n\n## Không còn code thừa (No Cruft)\n\nLoại bỏ những tính năng hiếm khi sử dụng như `this.isMounted`\nsẽ giúp React nhẹ hơn và linh hoạt hơn. Theo thời gian, điều\nnày sẽ giúp React nhanh hơn. Mình biết là tất cả chúng ta đều\nyêu React, nhưng chúng ta cũng muốn có tốc độ phải không nào ?\n\n## FlowTypes\n\nĐây là điều mà mình thích nhất. Trong một thời gian dài, mình\nđã cố tình bỏ qua Typescript và Flow, nhưng sau khi mất nguyên\nmột ngày vì gõ sai tên `sự kiện` (event), mình bắt đầu dùng\nFlow và chưa bao giờ nhìn lại. Flow giúp bạn thực hiện chuyển\nđổi một cách chậm chạp, theo từng file. Và đừng xem thường, nó\nsẽ giúp bạn tìm ra hàng tá lỗi mà bạn chưa từng biết đến sự\ntồn tại.\n\nNhưng điều này giúp ích gì khi dùng ES6 class ?\nFlowtype và Typescript sẽ dễ dàng hơn nếu bạn đang dùng ES6 class.\n\nĐây là một ví dụ:\n\nES6 class\n\n```js\nclass X extends React.Component {\n  someProp: string | number;\n  state: SomeType;\n  props: SomeType;\n  ...\n}\n```\n\nReact.createClass\n\n```js\nReact.createClass({\n  someProp: (0: string | number),\n  ...\n})\n```\n\nVà sự thật là bạn không thể định kiểu (type) cho props và state với\nflow khi dùng React.createClass. Thay và đó, Flow phụ thuộc\nvào hàng tá code để có thể xác định kiểu bằng việc đọc `propTypes`.\nThực tế thì nó chưa bao giờ làm tốt như vậy. Và đừng có nghĩ đến việc\nkiểm tra kiểu (type checking) với state. Nó đơn giản là không thể.\n\n# Kết luận\n\nCả 2 kiểu tạo component như trên đều sẽ không biến mất trong\ntương lại gần. Nếu ES6 class trở thành cách mà mọi người chọn\nthay vì `createClass`, Javascript cần nhiều hơn là một `sugar syntax`\n(tạm dịch là cú pháp thân thuộc), nó cần `class` thực sự.\nMình chọn viết component bằng ES6 class vì nó nhìn gọn hơn,\nkhông cần đặt dấu phẩy và sau mỗi hàm, và những điều hạn chế\nkể trên với cú pháp này không ảnh hướng nhiều đến mình.\n","__filename":"react-component-voi-react-create-class.md","__url":"/react-component-voi-react-create-class/","__resourceUrl":"/react-component-voi-react-create-class/index.html","__dataUrl":"/react-component-voi-react-create-class/index.html.b4647d3db42f8ac1e4a7950ad7bfadbf.json","type":"Post"}}}</script><script src="/phenomic.browser.23f04e7a39b6760c1f26.js"></script><script src="/sw-register.js"></script></body></html>